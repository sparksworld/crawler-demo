[{"article_title":"借壳分享微信","description":"调研某款 App Android 版微信分享来源动态原理以及实现方式 第一时间，当然是看看网上有没有前辈开源，借鉴（CV 大法）一波。 查询结果真的是悲喜交加： 开森的是，有人研究过这个东西，也封装好了对应的 SDK。 悲剧的是收费，目前已了解的情况最低 100。 对于本身在 ...","mate":"4 天前","tags":{},"content":"\n                调研某款 App Android 版微信分享来源动态原理以及实现方式\n\n第一时间，当然是看看网上有没有前辈开源，借鉴（CV 大法）一波。\n查询结果真的是悲喜交加：\n\n开森的是，有人研究过这个东西，也封装好了对应的 SDK。\n悲剧的是收费，目前已了解的情况最低 100。\n\n对于本身在帝都讨生活的落魄小 Android 而言，无疑是一笔巨款 （手动滑稽～勿喷～）。\n都说穷人家的孩子早当家，不得已开始了逆向、分析之路 😂😂😂\n相关代码已上传 GitHub，当然为了不给自己找事儿，本地命中库就不提供了，自己逆向去拿吧，地址如下：\n\ngithub.com/HLQ-Struggl…\n\n效果图\n空谈无用，来个实际效果图最棒，这里就以我梦想殿堂 App 为例进行测试咯。\n\n准备工具\n基于个人了解简单概述：\n\nApkTools： 一般就是为了改包、回包，捎带脚拿个资源文件。\nClassyShark： 一款贼方便分析 Apk 工具，一般用于看看大厂都玩啥。\ndex2jar： 将 .dex 文件转换为 .class 文件。\nJD-GUI： 主要是查看反编译后的源代码。\n\n下面附上相关工具网盘链接：\n\n链接：pan.baidu.com/s/1Ll5cTqMu…  密码：20fl\n\n实战开搞\n在正式开始前，先来见识下 ClassyShark 这个神器吧。\n一、Hi，ClassyShark\n首先进入你下载好的 ClassyShark.jar 目录中，随后执行如下命令即可：\n\njava -jar ClassyShark.jar\n\n示意图如下：\n\n随后在打开的可视化工具中将想看的 Apk 直接拖进去即可：\n\n拖进去之后点击包名，会有一个对当前 Apk 的简单概述：\n\n点击 Methods count 可以查看当前 Apk 方法数：\n\n当然你可以继续往下一层级查看，比如我点击 bilibili：\n\n同样也可以导出文件，这里不作为本文重点阐述了，有兴趣的可以自己研究～\n二、逆向分析走起\n首先，网上下载目标 App，并将后缀名修改为 zip，随后解压进入该目录：\n\n手动进入已下载完成的 dex-tools-2.1-SNAPSHOT 目录中，执行如下命令：\n\nsh d2j-dex2jar.sh [目标 dex 文件地址]\n\n例如：\n\n完成之后，将会在 dex-tools-2.1-SNAPSHOT 目录中生成 classes-dex2jar.jar 文件，这里文件就是我们接下来逆向分析的靠山呐。\n随后将生成的 jar 文件拖入 JD-GUI 中。\n\n查看 AndroidManifest 获取到当前应用包名，有助于我们一步到位～\n由于目标 App 是在文章的详情页中提供分享微信消息回话以及朋友圈，详情一般个人命名为 XxxDetailsActivity，根据这个思路去搜索。\n\n有些尴尬啊，怎么搜索到了腾讯的 SDK 呢？\n还是手动人工查找吧，😂😂😂\n\n在这块发现个比较有意思的东西，可能是我比较 low 吧。一般而言，我们都知道混淆实体类是肯定不能被混淆的，不然就会出现找不到的情况。那么奇怪了，昨天逆向 B 站 Apk，我竟然没发现实体类，难道他们的实体类有其他神操作？还是说分包太多我没找到？\n终于找到你，文章详情页！！！\n\n操作 App，发现是点击按钮弹出底部分享对话框，原版如下：\n\n随后继续在代码中查看，果然：\n\n这个就很好理解了，自定义一个底部对话框，点击传递分享的 Url 以及分享类型。现在我们去 ShareArticleDialog 这个类中验证一下猜想是否正确？\n\n看，0 应该是代表分享微信消息会话，1 代表分享朋友圈。\n经过一番排查，发现最终是通过调用如下方法进行分享微信：\npublic static int send(Context paramContext, String paramString1, String paramString2, String paramString3, Bundle paramBundle) {\n    CURRENT_SHARE_CLIENT = null;\n    if (paramContext == null || paramString1 == null || paramString1.length() == 0 || paramString2 == null || paramString2.length() == 0) {\n      Log.w(\"MMessageAct\", \"send fail, invalid arguments\");\n      return -1;\n    } \n    Intent intent = new Intent();\n    intent.setClassName(paramString1, paramString2);\n    if (paramBundle != null)\n      intent.putExtras(paramBundle); \n    intent.putExtra(\"_mmessage_sdkVersion\", 603979778);\n    int i = getPackageSign(paramContext);\n    if (i == -1)\n      return -1; \n    CURRENT_SHARE_CLIENT = shareClient.get(i);\n    intent.putExtra(\"_mmessage_appPackage\", \"这里换成要借壳 App 包名\");\n    StringBuilder stringBuilder = new StringBuilder();\n    stringBuilder.append(\"weixin://sendreq?appid=\");\n    stringBuilder.append(\"这里换成要借壳 AppId\");\n    intent.putExtra(\"_mmessage_content\", stringBuilder.toString());\n    intent.putExtra(\"_mmessage_checksum\", MMessageUtil.signatures(paramString3, paramContext.getPackageName()));\n    intent.addFlags(268435456).addFlags(134217728);\n    try {\n      paramContext.startActivity(intent);\n      StringBuilder stringBuilder1 = new StringBuilder();\n      this();\n      stringBuilder1.append(\"send mm message, intent=\");\n      stringBuilder1.append(intent);\n      Log.d(\"MMessageAct\", stringBuilder1.toString());\n      return i;\n    } catch (Exception exception) {\n      exception.printStackTrace();\n      Log.d(\"MMessageAct\", \"send fail, target ActivityNotFound\");\n      return -1;\n    } \n}\n复制代码在查看微信 SDK 中也发现类似代码，由于掘金这个上传图片宽高我现在还不会调整，暂时防止目录位置，感兴趣的小伙伴自行查看：\n\n其它细节就不一一分析了，直接上代码咯～\n三、附上代码～\n其实本质借壳分享，个人的理解如下：\n\n第一步：绕过微信检测，例如包名、签名是否和微信开放平台绑定一致；\n第二部：组装参数，直接直击深处，分享微信。\n\n由于此次是 Flutter 项目，不得不的面对的是与原生 Android 的交互。由于我是刚刚入坑 Flutter 几周，内心真的是忐忑不安。\n不过值得让人赞叹的是，Flutter 的生态，真的贼棒！尤其我鸡老大，神一般存在！默默的感谢我大哥～！\n0. 简单聊下 Flutter 与交互\n在 Flutter 中文社区中官网对此有这样的一段描述：\n\nFlutter 使用了灵活的系统，它允许你调用相关平台的 API，无论是 Android 中的 Java 或 Kotlin 代码，还是 iOS 中的 Objective-C 或 Swift 代码。\nFlutter 内置的平台特定 API 支持不依赖于任何生成代码，而是灵活的依赖于传递消息格式。或者，你也可以使用 Pigeon 这个 >\npackage，通过生成代码来发送结构化类型安全消息。\n\n\n应用程序中的 Flutter 部分通过平台通道向其宿主（应用程序中的 iOS 或 Android 部分）发送消息。\n\n\n宿主监听平台通道并接收消息。然后，它使用原生编程语言来调用任意数量的相关平台 API，并将响应发送回客户端（即应用程序中的 Flutter 部分）。\n\n\n\n也就是说，Flutter 充分给予我们调用原生 Api 的权利，关键桥梁便是这个通道消息。\n下面一起来看下官方的图：\n\n\n消息和响应以异步的形式进行传递，以确保用户界面能够保持响应。\n客户端做方法调用的时候 MethodChannel 会负责响应，从平台一侧来讲，Android 系统上使用 MethodChannelAndroid、 iOS 系统使用 MethodChanneliOS 来接收和返回来自 MethodChannel 的方法调用。\n\n其实对于我一个新手而言，看这些真的似懂非懂，所以过多的等以后掌握了之后再来探讨吧。这块内容将在下面代码部分着重说明。\n1. 引入三方库\napi 'com.tencent.mm.opensdk:wechat-sdk-android-without-mta:+'\n// 主要用于将分享的在线图片转换为 Bitmap\nimplementation 'com.github.bumptech.glide:glide:4.11.0'\nannotationProcessor 'com.github.bumptech.glide:compiler:4.11.0'\nimplementation 'com.google.code.gson:gson:2.8.6'\n复制代码2. 完善混淆文件\n# 保护我方输出（保护实体类不被混淆）\n-keep public class com.Your Package Name.bean.**{*;}\n\n# Gson\n-keepattributes Signature\n# Gson specific classes\n-keep class sun.misc.Unsafe { *; }\n-keep class com.google.gson.** { *; }\n# Application classes that will be serialized/deserialized over Gson\n-keep class com.google.gson.examples.android.model.** { *; }\n复制代码3. 编写原生 Android 工具类\n这里具体还是需要结合实际项目需求而定，不过通用型的一些东西必须要有：\n\n动态检测宿主，也可以理解为动态检测借壳目标是否存在；\n\n而剩下的则是分享微信了，这里简单放置关键代码，详情可点击文章开始的 GitHub 地址。\npackage com.hlq.struggle.utils\n\nimport android.content.Context\nimport android.content.Intent\nimport android.graphics.Bitmap\nimport android.os.Bundle\nimport com.bumptech.glide.Glide\nimport com.bumptech.glide.load.DataSource\nimport com.bumptech.glide.load.engine.GlideException\nimport com.bumptech.glide.request.RequestListener\nimport com.bumptech.glide.request.target.Target\nimport com.google.gson.Gson\nimport com.google.gson.reflect.TypeToken\nimport com.hlq.struggle.app.appInfoJson\nimport com.hlq.struggle.bean.AppInfoBean\nimport com.tencent.mm.opensdk.modelmsg.SendMessageToWX\nimport com.tencent.mm.opensdk.modelmsg.WXMediaMessage\nimport com.tencent.mm.opensdk.modelmsg.WXMediaMessage.IMediaObject\nimport com.tencent.mm.opensdk.modelmsg.WXWebpageObject\nimport java.io.ByteArrayOutputStream\nimport java.io.IOException\n\n/**\n * @author：HLQ_Struggle\n * @date：2020/6/27\n * @desc：\n */\n@Suppress(\"SpellCheckingInspection\")\nclass ShareWeChatUtils {\n\n    companion object {\n\n        /**\n         * 解析本地缓存 App 信息\n         */\n        private fun getLocalAppCache(): ArrayList<AppInfoBean> {\n            return Gson().fromJson(\n                    appInfoJson,\n                    object : TypeToken<ArrayList<AppInfoBean>>() {}.type\n            )\n        }\n\n        /**\n         * 检测用户设备安装 App 信息\n         */\n        fun checkAppInstalled(context: Context): Int {\n            var tempCount = -1\n            // 获取本地宿主 App 信息\n            val appInfoList = getLocalAppCache()\n            // 获取用户设备已安装 App 信息\n            val packageManager = context.packageManager\n            val installPackageList = packageManager.getInstalledPackages(0)\n            if (installPackageList.isEmpty()) {\n                return 0\n            }\n            for (packageInfo in installPackageList) {\n                for (appInfo in appInfoList) {\n                    if (packageInfo.packageName == appInfo.packageName) {\n                        tempCount++\n                    }\n                }\n            }\n            return tempCount\n        }\n\n        /**\n         * 命中已安装 App\n         */\n        private fun hitInstalledApp(context: Context): AppInfoBean? {\n            // 获取本地宿主 App 信息\n            val appInfoList = getLocalAppCache()\n            // 获取用户设备已安装 App 信息\n            val packageManager = context.packageManager\n            // 能进入方法说明本地已存在命中 App，使用时还需要预防\n            val installPackageList = packageManager.getInstalledPackages(0)\n            for (packageInfo in installPackageList) {\n                for (appInfo in appInfoList) {\n                    if (packageInfo.packageName == appInfo.packageName) {\n                        return appInfo\n                    }\n                }\n            }\n            return null\n        }\n\n        /**\n         * 分享微信\n         */\n        fun shareWeChat(\n                context: Context,\n                shareType: Int,\n                url: String,\n                title: String,\n                text: String,\n                paramString4: String?,\n                umId: String?\n        ) {\n            Glide.with(context).asBitmap().load(paramString4)\n                    .listener(object : RequestListener<Bitmap?> {\n                        override fun onLoadFailed(\n                                param1GlideException: GlideException?,\n                                param1Object: Any,\n                                param1Target: Target<Bitmap?>,\n                                param1Boolean: Boolean\n                        ): Boolean {\n                            LogUtils.logE(\" ---> Load Image Failed\")\n                            return false\n                        }\n\n                        override fun onResourceReady(\n                                param1Bitmap: Bitmap?,\n                                param1Object: Any,\n                                param1Target: Target<Bitmap?>,\n                                param1DataSource: DataSource,\n                                param1Boolean: Boolean\n                        ): Boolean {\n                            LogUtils.logE(\" ---> Load Image Ready\")\n                            val i =\n                                    send(\n                                            context,\n                                            shareType,\n                                            url,\n                                            title,\n                                            text,\n                                            param1Bitmap\n                                    )\n                            val stringBuilder = StringBuilder()\n                            stringBuilder.append(\"send index: \")\n                            stringBuilder.append(i)\n                            LogUtils.logE(\" ---> Ready stringBuilder.toString() :$stringBuilder\")\n                            return false\n                        }\n                    }).preload(200, 200)\n        }\n\n        private fun send(\n                paramContext: Context,\n                paramInt: Int,\n                paramString1: String,\n                paramString2: String,\n                paramString3: String,\n                paramBitmap: Bitmap?\n        ): Int {\n            val stringBuilder = StringBuilder()\n            stringBuilder.append(\"share url: \")\n            stringBuilder.append(paramString1)\n            LogUtils.logE(\" ---> send :$stringBuilder\")\n            val wXWebpageObject = WXWebpageObject()\n            wXWebpageObject.webpageUrl = paramString1\n            val wXMediaMessage = WXMediaMessage(wXWebpageObject as IMediaObject)\n            wXMediaMessage.title = paramString2\n            wXMediaMessage.description = paramString3\n            wXMediaMessage.thumbData =\n                    bmpToByteArray(\n                            paramContext,\n                            Bitmap.createScaledBitmap(paramBitmap!!, 150, 150, true),\n                            true\n                    )\n            val req = SendMessageToWX.Req()\n            req.transaction =\n                    buildTransaction(\n                            \"webpage\"\n                    )\n            req.message = wXMediaMessage\n            req.scene = paramInt\n            val bundle = Bundle()\n            req.toBundle(bundle)\n            return sendToWx(\n                    paramContext,\n                    \"weixin://sendreq?appid=wxd930ea5d5a258f4f\",\n                    bundle\n            )\n        }\n\n        private fun buildTransaction(paramString: String): String {\n            var paramString: String? = paramString\n            paramString = if (paramString == null) {\n                System.currentTimeMillis().toString()\n            } else {\n                val stringBuilder = StringBuilder()\n                stringBuilder.append(paramString)\n                stringBuilder.append(System.currentTimeMillis())\n                stringBuilder.toString()\n            }\n            return paramString\n        }\n\n        private fun bmpToByteArray(\n                paramContext: Context?,\n                paramBitmap: Bitmap,\n                paramBoolean: Boolean\n        ): ByteArray? {\n            val byteArrayOutputStream =\n                    ByteArrayOutputStream()\n            try {\n                paramBitmap.compress(Bitmap.CompressFormat.PNG, 100, byteArrayOutputStream)\n                if (paramBoolean) paramBitmap.recycle()\n                val arrayOfByte = byteArrayOutputStream.toByteArray()\n                byteArrayOutputStream.close()\n                return arrayOfByte\n            } catch (iOException: IOException) {\n                iOException.printStackTrace()\n            }\n            return null\n        }\n\n        private fun sendToWx(\n                paramContext: Context?,\n                paramString: String?,\n                paramBundle: Bundle?\n        ): Int {\n            return send(\n                    paramContext,\n                    \"com.tencent.mm\",\n                    \"com.tencent.mm.plugin.base.stub.WXEntryActivity\",\n                    paramString,\n                    paramBundle\n            )\n        }\n\n        private fun send(\n                paramContext: Context?,\n                packageName: String?,\n                className: String?,\n                paramString3: String?,\n                paramBundle: Bundle?\n        ): Int {\n            if (paramContext == null || packageName == null || packageName.isEmpty() || className == null || className.isEmpty()) {\n                LogUtils.logE(\" ---> send fail, invalid arguments\")\n                return -1\n            }\n            val appInfoBean = hitInstalledApp(paramContext)\n            val intent = Intent()\n            intent.setClassName(packageName, className)\n            if (paramBundle != null) intent.putExtras(paramBundle)\n            intent.putExtra(\"_mmessage_sdkVersion\", 603979778)\n            intent.putExtra(\"_mmessage_appPackage\", appInfoBean?.packageName)\n            val stringBuilder = StringBuilder()\n            stringBuilder.append(\"weixin://sendreq?appid=\")\n            stringBuilder.append(appInfoBean?.packageSign)\n            intent.putExtra(\"_mmessage_content\", stringBuilder.toString())\n            intent.putExtra(\n                    \"_mmessage_checksum\",\n                    MMessageUtils.signatures(paramString3, paramContext.packageName)\n            )\n            intent.addFlags(268435456).addFlags(134217728)\n            return try {\n                paramContext.startActivity(intent)\n                val sb = StringBuilder()\n                sb.append(\"send mm message, intent=\")\n                sb.append(intent)\n                LogUtils.logE(\" ---> sb :$sb\")\n                0\n            } catch (exception: Exception) {\n                exception.printStackTrace()\n                LogUtils.logE(\" --->  send fail, target ActivityNotFound\")\n                -1\n            }\n        }\n    }\n}\n复制代码4. 对 Flutter 暴露通道\n这块需要注意几点，现在你可以理解为你在编写一个 Flutter 的小型插件，那么你需要向外部暴露一些你规定的类型，或者说方法。这个不难理解吧。\n好比你去调用某个 SDK，官方一定是告知了一些重要的特性。那么针对我们现在的这个小插件，它比较关键的特性又是什么？\n关于这个特性，个人这里分为俩个部分来说：\n内部特性：\n\n本地命中宿主缓存 Json。这块主要是需要个人去维护，去抓去目前常用的一个 App 的相关信息，不断完善。\n\n外部特性：\n\n通道名称。这个理解起来比较容易，好比你拿着 A 小区的通行证进入 B 小区，那么 B 小区的保安大叔肯定会给你拦下来，而反之你进入 A 小区则畅行无阻。\n对外暴露方法。比如说我现在对外暴露俩个方法，一个为检测命中宿主数量一个为实际的微信分享。\n关键参数描述。例如微信分享类型，目前偷个懒，Flutter 调用时只需要传递 bool 类型即可，SDK 内部会自行匹配。\n\n针对以上内容，这里提取配置类：\npackage com.hlq.struggle.app\n\n/**\n * @author：HLQ_Struggle\n * @date：2020/6/27\n * @desc：\n */\n\n/**\n * 通道名称\n */\nconst val channelName = \"HLQStruggle\"\n\n/**\n * 检测命中数量 > 0 代表可采用命中宿主方案借壳分享\n */\nconst val checkAppInstalledChannel = \"checkAppInstalled\"\n\n/**\n * 分享微信\n */\nconst val shareWeChatChannel = \"shareWeChat\"\n\n/**\n * 分享微信消息会话\n */\nconst val shareWeChatSession = 0\n\n/**\n * 分享微信朋友圈\n */\nconst val shareWeChatLine = 1\n\n/**\n * 本地缓存 App 信息\n */\nconst val appInfoJson =\n        \"[{\\\"appName\\\":\\\"App Name\\\",\\\"downloadUrl\\\":\\\"\\\",\\\"optional\\\":1,\\\"packageName\\\":\\\"Package Name\\\",\\\"packageSign\\\":\\\"App WeChat ID\\\",\\\"type\\\":1}]\"\n复制代码下面则是本地工具类，拼接参数，发送微信：\npackage com.hlq.struggle\n\nimport com.hlq.struggle.app.*\nimport com.hlq.struggle.utils.ShareWeChatUtils.Companion.checkAppInstalled\nimport com.hlq.struggle.utils.ShareWeChatUtils.Companion.shareWeChat\nimport io.flutter.embedding.android.FlutterActivity\nimport io.flutter.embedding.engine.FlutterEngine\nimport io.flutter.plugin.common.MethodCall\nimport io.flutter.plugin.common.MethodChannel\nimport io.flutter.plugins.GeneratedPluginRegistrant\n\nclass MainActivity: FlutterActivity() {\n\n    override fun configureFlutterEngine(flutterEngine: FlutterEngine) {\n        GeneratedPluginRegistrant.registerWith(flutterEngine)\n        // 处理 Flutter 传递过来的消息\n        handleMethodChannel(flutterEngine)\n    }\n\n    private fun handleMethodChannel(flutterEngine: FlutterEngine) {\n        MethodChannel(flutterEngine.dartExecutor, channelName).setMethodCallHandler { methodCall: MethodCall, result: MethodChannel.Result? ->\n            when (methodCall.method) {\n                checkAppInstalledChannel -> { // 获取命中 App 数量\n                    result?.success(checkAppInstalled(activity))\n                }\n                shareWeChatChannel -> {  // 分享微信\n                    val shareType = if (methodCall.argument<Boolean>(\"isScene\")!!) {\n                        shareWeChatSession\n                    } else {\n                        shareWeChatLine\n                    }\n                    result?.success(shareWeChat(\n                            this, shareType,\n                            methodCall.argument<String>(\"shareUrl\")!!,\n                            methodCall.argument<String>(\"shareTitle\")!!,\n                            methodCall.argument<String>(\"shareDesc\")!!,\n                            methodCall.argument<String>(\"shareThumbnail\")!!, \"\"))\n                }\n                else -> {\n                    result?.notImplemented()\n                }\n            }\n        }\n    }\n\n}\n复制代码5. Flutter 端调用\n这里个人习惯，首先定义一个常量类，将 SDK 或者说 Android 端插件暴露参数定义一下，使用时统一调用，方便然后维护。\n/// @date 2020-06-27\n/// @author HLQ_Struggle\n/// @desc 常量类\n\n/// 通道名称\nconst String channelName = 'HLQStruggle';\n\n/// 检测命中数量 > 0 代表可采用命中宿主方案借壳分享\nconst String checkAppInstalled = 'checkAppInstalled';\n\n/// 分享微信\nconst String shareWeChat = 'shareWeChat'; \n复制代码而对于 Flutter 调用 Android 原生则比较 easy 了，相关注意的点已在代码中注释，这里直接附上对应的关键代码：\nclass _MyHomePageState extends State<MyHomePage> {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.title),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: <Widget>[\n            GestureDetector(\n              onTap: () async {\n                _shareWeChatApp(true);\n              },\n              child: Text(\n                '点我分享微信消息会话',\n              ),\n            ),\n            GestureDetector(\n              onTap: () async {\n                _shareWeChatApp(false);\n              },\n              child: Padding(\n                padding: EdgeInsets.only(top: 30),\n                child: Text(\n                  '点我分享微信朋友圈',\n                ),\n              ),\n            )\n          ],\n        ),\n      ),\n    );\n  }\n\n  /// 具体分享微信方式：true：消息会话 false：朋友圈\n  /// 提前调取通道验证采用官方 SDK 还是借壳方案\n  void _shareWeChatApp(bool isScene) async {\n    /// 这里一定注意通道名称俩端一致\n    const platform = const MethodChannel(channelName);\n    int tempHitNum = 0;\n    try {\n      tempHitNum = await platform.invokeMethod(checkAppInstalled);\n    } catch (e) {\n      print(e);\n    }\n    if (tempHitNum > 0) {\n      // 当前设备存在目标宿主 - 开始执行分享\n      await platform.invokeMethod(shareWeChat, {\n        'isScene': isScene,\n        'shareTitle': '我是分享标题',\n        'shareDesc': '我是分享内容',\n        'shareUrl': 'https://juejin.im/post/6844904177345232909',\n\n        /// 分享内容在线地址\n        'shareThumbnail':\n            'https://user-gold-cdn.xitu.io/2018/9/27/16618fef8bbf66fb?imageView2/1/w/180/h/180/q/85/format/webp/interlace/1'\n\n        /// 分享图片在线地址\n      });\n    } else {\n      // 当前设备不存在目前宿主\n    }\n  }\n}\n复制代码好了，整个一个流程完成了。我们看下最后实际分享的效果：\n6. 查看效果\n\n分享微信消息会话\n\n\n分享成功提示，重点在分享来源：\n\n            "},{"article_title":"用nodejs写一个简单的alfred workflow","description":"前言：工作中很多时候都要讲究效率，把一些繁琐重复的事精简化。能使你的工作都事半功倍～ 我用的环境node v10.19.0, npm 6.13.4, alfred 4.0.9 如果你还不了解alfred, 点此进入 废话不多说, 就用nodejs做个alfred的work ...","mate":"2 个月前","tags":{"0":{},"1":{},"2":{}},"content":"\n                \n前言：工作中很多时候都要讲究效率，把一些繁琐重复的事精简化。能使你的工作都事半功倍～\n\n\n我用的环境node v10.19.0, npm 6.13.4, alfred 4.0.9\n\n\n如果你还不了解alfred, 点此进入\n\n废话不多说, 就用nodejs做个alfred的workflow工具, 功能需求：\n\n获取局域网的IP地址\n获取公网的IP地址\n输入IP地址查询归属地\n\n\n因为我本人是从事前端开发的，nodejs对我来说并不陌生，所以今天就讲讲ndoejs开发workflow插件\n制作初衷：我做的移动端项目很多，常常需要手机与电脑连接一个局域网下进行调试，每次都要查询一下自己的网卡IP。很容易就把自己给累死（哈哈）\n\n先上效果图\n\n\n直接输入ip\n\n\n\n直接输入ipp\n\n\n\n输入ip + IP地址\n\n\n\n搞起来\n\n开始前需要了解一下alfy\n\n\n\n打开alfred的Preferences,找到WorkFlows,选择列表底部的+号，选择Blank Workflow\n\n\n\n填写插件名字，描述，分类及版本信息，作者，网站。图标找个喜欢的拖拽到右侧方框里就行了\n\n\n\n\nBundle Id必须填写\n\n\n\n空白区域点击右键，选择Inputs => Script Filter,会弹出一个框\n\n\n\n如下填写, 填写之后点击save\n\n\n\n点击列表中，新建的workFlow选择open in Finder\n\n\n\n用自己顺手的编辑器(我用的vscode)打开项目文件夹,并调出终端,在当前文件夹执行npm init -y\n\n运行完之后需要安装一下依赖\nnpm i afly ip --save\n\n\n根目录新建index.js\nconst alfy = require(\"alfy\");\nconst ip = require(\"ip\");\n\nconst localNetWork = ip.address();\n\nalfy.output([\n    {\n        title: \"局域网地址：\" + localNetWork,\n        subtitle: \"Press ⌘L to see the full error and ⌘C to copy it.\",\n        arg: localNetWork\n    }\n]);\n终端运行一下node index.js,查看输出是否正常，如下正常输出就over\n\n\n\n调出alfred出入框窗口，输入ip, 显示如下就成功了\n\n\n\n回车将结果放到剪切板（回到workflow页面， 右键弹出菜单，选中，点击后会弹出窗口，直接点击save保存即可～）\n\n\n\n\n到这里基本流程已经结束，剩下的还需同志们继续努力💪\n\n需要剩余功能的同学请在结尾处下载使用，需要申请一个ak参数，请自行填写\n\n\n最后\n\nNodejs for ip下载\n项目地址\n\n\n            "},{"article_title":"HTTP1.0、HTTP1.1 和 HTTP2.0 的区别","description":"早在 HTTP 建立之初，主要就是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的HTML页面将要放在我们的 web 服务器上，用户端通过浏览器访问url地址来获取网页的显示内容，但是到了 WEB2.0 以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的 HTML 页面有了 CSS，Javascript，来丰富我们的页面展示，当 ajax 的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于 HTTP 协议的 ...","mate":"3 个月前","tags":{"0":{},"1":{}},"content":"\n                \n    \n        \n            \n                \n                    \n                        \n                            \n                                \n                                    \n                                        \n                                            \n                                                \n                                                    一、HTTP的历史\n                                                \n                                            \n                                        \n                                    \n                                \n                            \n                        \n                    \n                \n            \n            \n                \n                    \n                        早在 HTTP 建立之初，主要就是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。也是说对于前端来说，我们所写的HTML页面将要放在我们的 web\n                            服务器上，用户端通过浏览器访问url地址来获取网页的显示内容，但是到了 WEB2.0 以来，我们的页面变得复杂，不仅仅单纯的是一些简单的文字和图片，同时我们的 HTML 页面有了\n                            CSS，Javascript，来丰富我们的页面展示，当 ajax 的出现，我们又多了一种向服务器端获取数据的方法，这些其实都是基于\n                            HTTP 协议的。同样到了移动互联网时代，我们页面可以跑在手机端浏览器里面，但是和 PC 相比，手机端的网络情况更加复杂，这使得我们开始了不得不对 HTTP\n                            进行深入理解并不断优化过程中。\n                        \n                        \n                        \n                    \n                \n            \n            \n                \n                    \n                        \n                            \n                                \n                                    \n                                        \n                                            \n                                                \n                                                    二、HTTP的基本优化\n                                                \n                                            \n                                        \n                                    \n                                \n                            \n                        \n                    \n                \n            \n            \n                \n                    \n                        影响一个 HTTP 网络请求的因素主要有两个：带宽和延迟。\n                        \n                            \n                                带宽：如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。\n                                \n                            \n                            \n                                延迟：\n                            \n                            \n                                \n                                    浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4\n                                        个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。\n                                \n                                \n                                    DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是\n                                        DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。\n                                \n                                \n                                    建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP\n                                        请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。\n                                    \n                                \n                            \n                        \n                    \n                \n            \n            \n                \n                    \n                        \n                            \n                                \n                                    \n                                        \n                                            \n                                                \n                                                    三、HTTP1.0和HTTP1.1的一些区别\n                                                \n                                            \n                                        \n                                    \n                                \n                            \n                        \n                    \n                \n            \n            \n                \n                    \n                        HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。\n                            主要区别主要体现在：\n                        \n                            \n                                \n                                        缓存处理，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity\n                                    tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。\n                            \n                            \n                                带宽优化及网络连接的使用，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial\n                                    Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。\n                            \n                            \n                                错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。\n                                \n                            \n                            \n                                Host头处理，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed\n                                    Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400\n                                    Bad Request）。\n                            \n                            \n                                长连接，HTTP\n                                    1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection：\n                                    keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。\n                            \n                        \n                    \n                \n            \n            \n                \n                    \n                        \n                            \n                                \n                                    \n                                        \n                                            \n                                                \n                                                    四、HTTPS与HTTP的一些区别\n                                                \n                                            \n                                        \n                                    \n                                \n                            \n                        \n                    \n                \n            \n            \n                \n                    \n                        \n                            \n                                HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。\n                            \n                            \n                                HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。\n                            \n                            \n                                HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。\n                            \n                            \n                                HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。\n                            \n                        \n                        \n                            \n                        \n                    \n                \n            \n            \n                \n                    \n                        \n                            \n                                \n                                    \n                                        \n                                            \n                                                \n                                                    五、SPDY：HTTP1.x的优化\n                                                \n                                            \n                                        \n                                    \n                                \n                            \n                        \n                    \n                \n            \n            \n                \n                    \n                        2012年google如一声惊雷提出了SPDY的方案，优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下：\n                        \n                            \n                                降低延迟，针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL\n                                    blocking的问题，降低了延迟同时提高了带宽的利用率。\n                            \n                            \n                                请求优先级（request\n                                    prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。\n                                \n                            \n                            \n                                header压缩。前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。\n                            \n                            \n                                基于HTTPS的加密协议传输，大大提高了传输数据的可靠性。\n                            \n                            \n                                服务端推送（server\n                                    push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY构成图：\n                                \n                            \n                        \n                        \n                        \n                        SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。\n                        \n                            \n                                \n                                    \n                                        \n                                            \n                                                \n                                                    \n                                                        \n                                                            \n                                                                六、HTTP2.0性能惊人\n                                                            \n                                                        \n                                                    \n                                                \n                                            \n                                        \n                                    \n                                \n                            \n                        \n                        HTTP/2: the Future of the Internet\n                            https://link.zhihu.com/?target=https://http2.akamai.com/demo 是 Akamai 公司建立的一个官方的演示，用以说明\n                            HTTP/2 相比于之前的 HTTP/1.1 在性能上的大幅度提升。 同时请求 379 张图片，从Load time 的对比可以看出 HTTP/2 在速度上的优势。\n                        \n                        \n                        \n                        \n                            \n                                \n                                    \n                                        \n                                            \n                                                \n                                                    \n                                                        \n                                                            \n                                                                七、HTTP2.0：SPDY的升级版\n                                                            \n                                                        \n                                                    \n                                                \n                                            \n                                        \n                                    \n                                \n                            \n                        \n                        HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，如下：\n                        HTTP2.0和SPDY的区别：\n                        \n                            \n                                HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS\n                            \n                            \n                                HTTP2.0 消息头的压缩算法采用 HPACK\n                                    http://http2.github.io/http2-spec/compression.html，而非 SPDY 采用的\n                                    DEFLATE http://zh.wikipedia.org/wiki/DEFLATE\n                            \n                        \n                        \n                            \n                                \n                                    \n                                        \n                                            \n                                                \n                                                    \n                                                        \n                                                            \n                                                                \n                                                                    \n                                                                        \n                                                                            八、HTTP2.0和HTTP1.X相比的新特性\n                                                                            \n                                                                        \n                                                                    \n                                                                \n                                                            \n                                                        \n                                                    \n                                                \n                                            \n                                        \n                                    \n                                    \n                                        \n                                            新的二进制格式（Binary\n                                                Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。\n                                            \n                                        \n                                        \n                                            多路复用（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的\n                                                id将request再归属到各自不同的服务端请求里面。\n                                        \n                                        \n                                            header压缩，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header\n                                                fields表，既避免了重复header的传输，又减小了需要传输的大小。\n                                        \n                                        \n                                            服务端推送（server push），同SPDY一样，HTTP2.0也具有server push功能。\n                                        \n                                    \n                                    \n                                        \n                                            \n                                                \n                                                    \n                                                        \n                                                            \n                                                                \n                                                                    \n                                                                        \n                                                                            九、HTTP2.0的升级改造\n                                                                        \n                                                                    \n                                                                \n                                                            \n                                                        \n                                                    \n                                                \n                                            \n                                        \n                                    \n                                    \n                                        \n                                            前文说了HTTP2.0其实可以支持非HTTPS的，但是现在主流的浏览器像chrome，firefox表示还是只支持基于 TLS\n                                                部署的HTTP2.0协议，所以要想升级成HTTP2.0还是先升级HTTPS为好。\n                                        \n                                        \n                                            当你的网站已经升级HTTPS之后，那么升级HTTP2.0就简单很多，如果你使用NGINX，只要在配置文件中启动相应的协议就可以了，可以参考NGINX白皮书，NGINX配置HTTP2.0官方指南 \n                                                https://www.nginx.com/blog/nginx-1-9-5/。\n                                        \n                                        \n                                            使用了HTTP2.0那么，原本的HTTP1.x怎么办，这个问题其实不用担心，HTTP2.0完全兼容HTTP1.x的语义，对于不支持HTTP2.0的浏览器，NGINX会自动向下兼容的。\n                                            \n                                        \n                                    \n                                    \n                                        \n                                            \n                                                \n                                                    \n                                                        \n                                                            \n                                                                \n                                                                    \n                                                                        \n                                                                            十、附注\n                                                                        \n                                                                    \n                                                                \n                                                            \n                                                        \n                                                    \n                                                \n                                            \n                                        \n                                    \n                                    HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？\n                                    \n                                        \n                                            HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；\n                                        \n                                        \n                                            HTTP/1.1\n                                                Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；\n                                            \n                                        \n                                        \n                                            HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；具体如图：\n                                        \n                                    \n                                    \n                                    \n                                    \n                                    \n                                        \n                                            \n                                        \n                                    \n                                    服务器推送到底是什么？服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。具体如下：\n                                    \n                                    \n                                        \n                                            普通的客户端请求过程：\n                                        \n                                    \n                                    \n                                        \n                                    \n                                    \n                                        \n                                            服务端推送的过程：\n                                        \n                                    \n                                    \n                                    \n                                        \n                                    \n                                    \n                                    为什么需要头部压缩？假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）,\n                                        而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）,\n                                        则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量。具体参考：HTTP/2\n                                        头部压缩技术介绍\n                                    HTTP2.0多路复用有多好？HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP\n                                        连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP\n                                        慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP\n                                        连接，让高带宽也能真正的服务于 HTTP\n                                        的性能提升。\n                                \n                            \n                        \n                    \n                \n            \n        \n    \n\n摘录原文地址HTTP1.0、HTTP1.1 和 HTTP2.0 的区别\n\n\n            "},{"article_title":"Linux Crontab 定时任务","description":"cron介绍 我们经常使用的是crontab命令是cron table的简写，它是cron的配置文件，也可以叫它作业列表，我们可以在以下文件夹内找到相关配置文件。 /var/spool/cron/ 目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命 ...","mate":"3 个月前","tags":{"0":{},"1":{}},"content":"\n                cron介绍\n我们经常使用的是crontab命令是cron table的简写，它是cron的配置文件，也可以叫它作业列表，我们可以在以下文件夹内找到相关配置文件。\n\n/var/spool/cron/ 目录下存放的是每个用户包括root的crontab任务，每个任务以创建者的名字命名\n/etc/crontab 这个文件负责调度各种管理和维护任务。\n/etc/cron.d/ 这个目录用来存放任何要执行的crontab文件或脚本。\n\n\n我们还可以把脚本放在/etc/cron.hourly、/etc/cron.daily、/etc/cron.weekly、/etc/cron.monthly目录中，让它每小时/天/星期、月执行一次。\n\ncrontab 使用命令如下\ncrontab [-u username]　　　　//省略用户表表示操作当前用户的crontab\n    -e      (编辑工作表)\n    -l      (列出工作表里的命令)\n    -r      (删除工作作)\n\n\n我们用crontab -e进入当前用户的工作表编辑，是常见的vim界面。每行是一条命令。\n\ncrontab的命令构成为 时间+动作，其时间有分、时、日、月、周五种，操作符有\n\n* 取值范围内的所有数字\n/ 每过多少个数字\n- 从X到Z\n， 散列数字\n\n常用定时任务\n\n每1分钟执行一次command\n\n* * * * * command\n\n每小时的第3和第15分钟执行command\n\n3,15 * * * * command\n\n在上午8点到11点的第3和第15分钟执行command\n\n3,15 8-11 * * * command\n\n每隔两天的上午8点到11点的第3和第15分钟执行command\n\n3,15 8-11 */2 * * command\n\n每周一上午8点到11点的第3和第15分钟执行command\n\n3,15 8-11 * * 1\n\n每晚的21:30执行command\n\n30 21 * * * command\n\n每月1、10、22日的4 : 45执行command\n\n45 4 1,10,22 * * command\n\n每周六、周日的1 : 10执行command\n\n10 1 * * 6,0 command\n\n每天18 : 00至23 : 00之间每隔30分钟执行command\n\n*/30 18-23 * * * command\n# 0,30 18-23 * * * command\n\n每星期六的晚上11 : 00 pm执行command\n\n0 23 * * 6 command\n\n每一小时执行command\n\n* */1 * * * command\n\n晚上11点到早上7点之间，每隔一小时执行command\n\n* 23-7/1 * * * command\n\n            "},{"article_title":"详解window.performance","description":"为了得到脚本运行的精确耗时，需要一个高精度时间戳，传统的做法是使用Date对象的getTime方法，其不足之处在于： getTime方法及Date对象的其他方法只能精确到毫秒级别，无法得到更小的时间精度； getTime方法只能获取脚本运行过程中的时间进度，无法知道一些后台事 ...","mate":"3 个月前","tags":{"0":{},"1":{}},"content":"\n                \n为了得到脚本运行的精确耗时，需要一个高精度时间戳，传统的做法是使用Date对象的getTime方法，其不足之处在于：\n\n\ngetTime方法及Date对象的其他方法只能精确到毫秒级别，无法得到更小的时间精度；\ngetTime方法只能获取脚本运行过程中的时间进度，无法知道一些后台事件的时间进度，比如浏览器用了多少时间从服务器加载网页。\n\n\n为了解决这两个不足之处，ES 5引入高精度时间戳——Performance API。Performance是浏览器对象，精度可以达到1毫秒的千分之一。即1秒的百万分之一，这不仅能衡量程序的细微差别，提高程序的运行速度，还可以获取后台事件的时间进度。\n\n\nPerformance API用于精确度量、控制、增强浏览器的性能表现，使测量网站性能达到前所未有的精度。目前，所有主要浏览器都已经支持performance对象，，包括Chrome 20+、Firefox 15+、IE 10+、Opera 15+。\n\nperformance.timing对象的属性：\n\n\n\n属性\n含义\n\n\n\n\nnavigationStart\n当前浏览器窗口的前一个网页关闭，发生unload事件时的Unix毫秒时间戳。如果没有前一个网页，则等于fetchStart属性。\n\n\nunloadEventStart\n当前浏览器窗口的前一个网页关闭，发生unload事件时的Unix毫秒时间戳。如果没有前一个网页，则等于fetchStart属性。\n\n\nunloadEventEnd\n如果前一个网页与当前网页属于同一个域名，则返回前一个网页unload事件的回调函数结束时的Unix毫秒时间戳。如果没有前一个网页，或者之前的网页跳转不是在同一个域名内，则返回值为0。\n\n\nredirectStart\n返回第一个HTTP跳转开始时的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0。\n\n\nredirectEnd\n返回最后一个HTTP跳转结束时（即跳转回应的最后一个字节接受完成时）的Unix毫秒时间戳。如果没有跳转，或者不是同一个域名内部的跳转，则返回值为0。\n\n\nfetchStart\n返回浏览器准备使用HTTP请求读取文档时的Unix毫秒时间戳。该事件在网页查询本地缓存之前发生。\n\n\ndomainLookupStart\n返回域名查询开始时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值。\n\n\ndomainLookupEnd\n返回域名查询结束时的Unix毫秒时间戳。如果使用持久连接，或者信息是从本地缓存获取的，则返回值等同于fetchStart属性的值。\n\n\nconnectStart\n返回HTTP请求开始向服务器发送时的Unix毫秒时间戳。如果使用持久连接（persistent connection），则返回值等同于fetchStart属性的值。\n\n\nconnectEnd\n返回浏览器与服务器之间的连接建立时的Unix毫秒时间戳。如果建立的是持久连接，则返回值等同于fetchStart属性的值。连接建立指的是所有握手和认证过程全部结束。\n\n\nsecureConnectionStart\n返回浏览器与服务器开始安全链接的握手时的Unix毫秒时间戳。如果当前网页不要求安全连接，则返回0。\n\n\nrequestStart\n返回浏览器向服务器发出HTTP请求时（或开始读取本地缓存时）的Unix毫秒时间戳。\n\n\nresponseStart\n返回浏览器从服务器收到（或从本地缓存读取）第一个字节时的Unix毫秒时间戳。\n\n\nresponseEnd\n返回浏览器从服务器收到（或从本地缓存读取）最后一个字节时（如果在此之前HTTP连接已经关闭，则返回关闭时）的Unix毫秒时间戳。\n\n\ndomLoading\n返回当前网页DOM结构开始解析时（即Document.readyState属性变为loading、相应的readystatechange事件触发时）的Unix毫秒时间戳。\n\n\ndomInteractive\n返回当前网页DOM结构结束解析、开始加载内嵌资源时（即Document.readyState属性变为interactive、相应的readystatechange事件触发时）的Unix毫秒时间戳。\n\n\ndomContentLoadedEventStart\n返回当前网页DOMContentLoaded事件发生时（即DOM结构解析完毕、所有脚本开始运行时）的Unix毫秒时间戳。\n\n\ndomContentLoadedEventEnd\n返回当前网页所有需要执行的脚本执行完成时的Unix毫秒时间戳。\n\n\ndomComplete\n返回当前网页DOM结构生成时（即Document.readyState属性变为complete，以及相应的readystatechange事件发生时）的Unix毫秒时间戳。\n\n\nloadEventStart\n返回当前网页load事件的回调函数开始时的Unix毫秒时间戳。如果该事件还没有发生，返回0。\n\n\nloadEventEnd\n返回当前网页load事件的回调函数运行结束时的Unix毫秒时间戳。如果该事件还没有发生，返回0。\n\n\n\n\nperformance.now()\n\nperformance.now()方法返回当前网页从performance.timing.navigationStart到当前时间之间的微秒数，其精度可达100万分之一秒。\n\n\nperformance.now()近似等于Date.now()，但前者返回的是毫秒，后者返回的是微秒，后者的精度比前者高1000倍。\n\nperformance.mark()\n\nperformance.mark方法用于为相应的视点做标记。\n\n\nperformance.clearMarks方法用于清除标记，如果不加参数，则清除所有标记。\n\nperformance.getEntries()\n\n浏览器获取网页时，会对网页中每一个对象，如js文件、css文件、图片文件等，发出一个HTTP请求。performance.getEntries方法以数组形式，返回这些请求的时间统计信息。\n\n\n由于performance.getEntries()方法与浏览器处理网页的过程相关，所以只能在浏览器中使用。\n\nperformance.navigation对象\n\n除时间信息，performance还可以提供用户行为信息，主要存放在performance.navigation对象上。\n\nperformance.navigation对象有两个属性：\n\n\nperformance.navigation.type 返回一个整数值，表示网页的加载来源，可能有以下4种\n\n0: 网页通过点击链接、地址栏输入、表单提交、脚本操作等方式加载，相当于常数performance.navigation.TYPE_NAVIGATENEXT。\n1: 网页通过重新加载按钮或location.reload()方法加载，相当于常数performance.navigation.TYPE_RELOAD。\n2: 网页通过前进或后退按钮加载，相当于常数performance.navigation.TYPE_BACK_FORWARD。\n255: 任何其他来源的加载，相当于常数performance.navigation.TYPE_UNDEFINED。\n\n\n\nperformance.navigation.redirectCount 该属性表示当前网页经过了多少次重定向跳转。\n\n\n\n            "},{"article_title":"在git中删除多个远程分支","description":"批量删除本地分支 git branch |grep 'v3.2.8' |xargs git branch -D 批量删远程分支 git branch -r | awk -Forigin/ '/\\/v3.2.8/{print $2}'| xargs -I {} git pus ...","mate":"4 个月前","tags":{},"content":"\n                批量删除本地分支\ngit branch |grep 'v3.2.8' |xargs git branch -D\n\n批量删远程分支\ngit branch -r | awk -Forigin/ '/\\/v3.2.8/{print $2}'| xargs -I {} git push origin :{}\n\n如果上面执行不成功，请检查将删除分支名\nsh     git branch -r | awk -Forigin/ '/\\/v3.2.8/ {print $2}'     \n\n\n\ngrep 命令用于查找文件里符合条件的字符串\nxargs xargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。\nawk命令\n\n\n            "}]