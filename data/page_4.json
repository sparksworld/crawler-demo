[{"article_title":"scripts 带入自定义命令参数","description":"一般情况下,项目中有非常多的地方使用npm scripts配置来跑一些任务,假设有这样一个场景,需要有四个环境, 分别要编译出每个环境对应的包,也许你会想: 我每个环境无非接口不一样,资源地址不一样,可以根据每个环境去修改后,再进行打包. 是的, 如果你不熟悉scripts命令 ...","mate":"2 年前","tags":["WEB技术","黑科技"],"content":"\n                一般情况下,项目中有非常多的地方使用npm scripts配置来跑一些任务,假设有这样一个场景,需要有四个环境, 分别要编译出每个环境对应的包,也许你会想: 我每个环境无非接口不一样,资源地址不一样,可以根据每个环境去修改后,再进行打包.\n\n是的, 如果你不熟悉scripts命令,这未尝不是办法, 但是如果你会用scripts命令,将会更加简单, 下面详细说一下scripts\n在项目中,package.json中经常看到这样的配置\n\npackage.json\n\n\"scripts\": {\n    \"dev\": \"webpack-dev-server --inline --config webpack.dev.js --colors\",\n    \"build\": \"webpack --config webpack.pro.js --colors\"\n  }\n以上指令中, 在命令行运行:\n\nnpm run dev ----> 运行此目录中webpack.dev.js文件\nnpm run build   ----> 执行编译指令,运行此目录中的webpack.pro.js\n\n如果说我想在命令行输入自定义参数,决定去构建某一分支,该怎么做呢?\n\n输入 man npm-config 你会看到这样的结果输出\n\nnpm gets its config settings from the command line, environment variables, npmrc files, and in some cases, the package.json file.\nnpm 运行时会从四个地方获取配置信息，命令行中的输入，环境变量，npmrc 配置文件以及，某些情况下会从 package.json 中获取。这里的某些情况就是指 package.json 中定义了 config 字段时。\n我们将变量放这里面（其实这里面的叫作配置项更确切，而不是变量）\n\n将package.json改成如下\n\n\"scripts\": {\n    \"dev\": \"webpack-dev-server --inline --config webpack.dev.js --colors --env.test=123456\",\n    \"build\": \"webpack --config webpack.pro.js --colors\"\n  }\n在webpack运行的文件的配置文件中接收自定义参数值\nmodule.exports = (env) => {\n    // 打印一下env里面存在什么值\n    console.log(env) // {test: '123456'}\n    return merge(common(env), {\n        mode: 'development',\n        output: {\n            filename: './js/app.js',\n            // chunkFilename: '[name].[chunkhash:22].js',\n            publicPath: '/',\n            path: path.resolve(__dirname, 'dist')\n        },\n        devtool: 'inline-source-map',\n        devServer: {\n            host: ip,\n            port: 8082,\n            open: true,\n            contentBase: path.join(__dirname, \"dist\"),\n            compress: true\n        },\n        plugins: [\n            new HtmlWebpackPlugin({ // Also generate a test.html\n                filename: '1508876.html',\n                template: './index.html'\n            })\n        ]\n    })\n}\n这样就能获取到scripts命令里面的参数了,但是怎么在输入命令的时候动态的传入参数呢?\n\n就像这种形式: npm run dev test=123456 我们可以借助环境变量这样做!\n\n\"scripts\": {\n    \"dev\": \"webpack-dev-server --inline --config webpack.dev.js --colors --env.test=$test\",\n    \"build\": \"webpack --config webpack.pro.js --colors\"\n  }\n\n注意,window和liunx环境变量参数带入是不一样的 window的写法为:\n\n\"scripts\": {\n    \"dev\": \"webpack-dev-server --inline --config webpack.dev.js --colors --env.test=%test%\",\n    \"build\": \"webpack --config webpack.pro.js --colors\"\n  }\n\n然后执行test=123456 npm run dev,打印env,是不是和刚才的一样呢?\n\n如果想兼容liunx和window 可以使用以下写法\n\"scripts\": {\n    \"dev\": \"webpack-dev-server --inline --config webpack.dev.js --colors --env.test=$test\",\n    \"dev:win\": \"webpack-dev-server --inline --config webpack.dev.js --colors --env.test=%test%\",\n  }\n但是这种写法, 自我感觉而言不太好.\n自然万事都有解决方案,可以使用cross-var或者cross-env-shell来解决系统之间的差异,具体可自行查找用法,这里就不多说了.如有问题欢迎留言!\n\n            "},{"article_title":"JavaScript 复杂判断的更优雅写法","description":"前提我们编写js代码时经常遇到复杂逻辑判断的情况，通常大家可以用if/else或者switch来实现多个条件判断，但这样会有个问题，随着逻辑复杂度的增加，代码中的if/else/switch会变得越来越臃肿，越来越看不懂，那么如何更优雅的写判断逻辑，本文带你试一下。举个例子先看一 ...","mate":"2 年前","tags":["WEB技术","相关技术"],"content":"\n                前提我们编写js代码时经常遇到复杂逻辑判断的情况，通常大家可以用if/else或者switch来实现多个条件判断，但这样会有个问题，随着逻辑复杂度的增加，代码中的if/else/switch会变得越来越臃肿，越来越看不懂，那么如何更优雅的写判断逻辑，本文带你试一下。举个例子先看一段代码/**\n * 按钮点击事件\n * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消\n */\nconst onButtonClick = (status)=>{\n  if(status == 1){\n    sendLog('processing')\n    jumpTo('IndexPage')\n  }else if(status == 2){\n    sendLog('fail')\n    jumpTo('FailPage')\n  }else if(status == 3){\n    sendLog('fail')\n    jumpTo('FailPage')\n  }else if(status == 4){\n    sendLog('success')\n    jumpTo('SuccessPage')\n  }else if(status == 5){\n    sendLog('cancel')\n    jumpTo('CancelPage')\n  }else {\n    sendLog('other')\n    jumpTo('Index')\n  }\n}通过代码可以看到这个按钮的点击逻辑：根据不同活动状态做两件事情，发送日志埋点和跳转到对应页面，大家可以很轻易的提出这段代码的改写方案，switch出场：/**\n * 按钮点击事件\n * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消\n */\nconst onButtonClick = (status)=>{\n  switch (status){\n    case 1:\n      sendLog('processing')\n      jumpTo('IndexPage')\n      break\n    case 2:\n    case 3:\n      sendLog('fail')\n      jumpTo('FailPage')\n      break\n    case 4:\n      sendLog('success')\n      jumpTo('SuccessPage')\n      break\n    case 5:\n      sendLog('cancel')\n      jumpTo('CancelPage')\n      break\n    default:\n      sendLog('other')\n      jumpTo('Index')\n      break\n  }\n}嗯，这样看起来比if/else清晰多了，细心的同学也发现了小技巧，case 2和case 3逻辑一样的时候，可以省去执行语句和break，则case 2的情况自动执行case 3的逻辑。这时有同学会说，还有更简单的写法：const actions = {\n  '1': ['processing','IndexPage'],\n  '2': ['fail','FailPage'],\n  '3': ['fail','FailPage'],\n  '4': ['success','SuccessPage'],\n  '5': ['cancel','CancelPage'],\n  'default': ['other','Index'],\n}\n/**\n * 按钮点击事件\n * @param {number} status 活动状态：1开团进行中 2开团失败 3 商品售罄 4 开团成功 5 系统取消\n */\nconst onButtonClick = (status)=>{\n  let action = actions[status] || actions['default'],\n      logName = action[0],\n      pageName = action[1]\n  sendLog(logName)\n  jumpTo(pageName)\n}上面代码确实看起来更清爽了，这种方法的聪明之处在于：将判断条件作为对象的属性名，将处理逻辑作为对象的属性值，在按钮点击的时候，通过对象属性查找的方式来进行逻辑判断，这种写法特别适合一元条件判断的情况。是不是还有其他写法呢？有的：const actions = new Map([\n  [1, ['processing','IndexPage']],\n  [2, ['fail','FailPage']],\n  [3, ['fail','FailPage']],\n  [4, ['success','SuccessPage']],\n  [5, ['cancel','CancelPage']],\n  ['default', ['other','Index']]\n])\n/**\n * 按钮点击事件\n * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消\n */\nconst onButtonClick = (status)=>{\n  let action = actions.get(status) || actions.get('default')\n  sendLog(action[0])\n  jumpTo(action[1])\n}这样写用到了es6里的Map对象，是不是更爽了？Map对象和Object对象有什么区别呢？一个对象通常都有自己的原型，所以一个对象总有一个\"prototype\"键。一个对象的键只能是字符串或者Symbols，但一个Map的键可以是任意值。你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认。我们需要把问题升级一下，以前按钮点击时候只需要判断status，现在还需要判断用户的身份：/**\n * 按钮点击事件\n * @param {number} status 活动状态：1开团进行中 2开团失败 3 开团成功 4 商品售罄 5 有库存未开团\n * @param {string} identity 身份标识：guest客态 master主态\n */\nconst onButtonClick = (status,identity)=>{\n  if(identity == 'guest'){\n    if(status == 1){\n      //do sth\n    }else if(status == 2){\n      //do sth\n    }else if(status == 3){\n      //do sth\n    }else if(status == 4){\n      //do sth\n    }else if(status == 5){\n      //do sth\n    }else {\n      //do sth\n    }\n  }else if(identity == 'master') {\n    if(status == 1){\n      //do sth\n    }else if(status == 2){\n      //do sth\n    }else if(status == 3){\n      //do sth\n    }else if(status == 4){\n      //do sth\n    }else if(status == 5){\n      //do sth\n    }else {\n      //do sth\n    }\n  }\n}原谅我不写每个判断里的具体逻辑了，因为代码太冗长了。原谅我又用了if/else，因为我看到很多人依然在用if/else写这种大段的逻辑判断。从上面的例子我们可以看到，当你的逻辑升级为二元判断时，你的判断量会加倍，你的代码量也会加倍，这时怎么写更清爽呢？const actions = new Map([\n  ['guest_1', ()=>{/*do sth*/}],\n  ['guest_2', ()=>{/*do sth*/}],\n  ['guest_3', ()=>{/*do sth*/}],\n  ['guest_4', ()=>{/*do sth*/}],\n  ['guest_5', ()=>{/*do sth*/}],\n  ['master_1', ()=>{/*do sth*/}],\n  ['master_2', ()=>{/*do sth*/}],\n  ['master_3', ()=>{/*do sth*/}],\n  ['master_4', ()=>{/*do sth*/}],\n  ['master_5', ()=>{/*do sth*/}],\n  ['default', ()=>{/*do sth*/}],\n])\n\n/**\n * 按钮点击事件\n * @param {string} identity 身份标识：guest客态 master主态\n * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 开团成功 4 商品售罄 5 有库存未开团\n */\nconst onButtonClick = (identity,status)=>{\n  let action = actions.get(`${identity}_${status}`) || actions.get('default')\n  action.call(this)\n}上述代码核心逻辑是：把两个条件拼接成字符串，并通过以条件拼接字符串作为键，以处理函数作为值的Map对象进行查找并执行，这种写法在多元条件判断时候尤其好用。当然上述代码如果用Object对象来实现也是类似的：const actions = {\n  'guest_1':()=>{/*do sth*/},\n  'guest_2':()=>{/*do sth*/},\n  //....\n}\n\nconst onButtonClick = (identity,status)=>{\n  let action = actions[`${identity}_${status}`] || actions['default']\n  action.call(this)\n}如果有些同学觉得把查询条件拼成字符串有点别扭，那还有一种方案，就是用Map对象，以Object对象作为key：const actions = new Map([\n  [{identity:'guest',status:1},()=>{/*do sth*/}],\n  [{identity:'guest',status:2},()=>{/*do sth*/}],\n  //...\n])\n\nconst onButtonClick = (identity,status)=>{\n  let action = [...actions].filter(([key,value])=>(key.identity == identity && key.status == status))\n  action.forEach(([key,value])=>value.call(this))\n}是不是又高级了一点点？这里也看出来Map与Object的区别，Map可以用任何类型的数据作为key。我们现在再将难度升级一点点，假如guest情况下，status1-4的处理逻辑都一样怎么办，最差的情况是这样：const actions = new Map([\n  [{identity:'guest',status:1},()=>{/* functionA */}],\n  [{identity:'guest',status:2},()=>{/* functionA */}],\n  [{identity:'guest',status:3},()=>{/* functionA */}],\n  [{identity:'guest',status:4},()=>{/* functionA */}],\n  [{identity:'guest',status:5},()=>{/* functionB */}],\n  //...\n])好一点的写法是将处理逻辑函数进行缓存：const actions = ()=>{\n  const functionA = ()=>{/*do sth*/}\n  const functionB = ()=>{/*do sth*/}\n  return new Map([\n    [{identity:'guest',status:1},functionA],\n    [{identity:'guest',status:2},functionA],\n    [{identity:'guest',status:3},functionA],\n    [{identity:'guest',status:4},functionA],\n    [{identity:'guest',status:5},functionB],\n    //...\n  ])\n}\n\nconst onButtonClick = (identity,status)=>{\n  let action = [...actions()].filter(([key,value])=>(key.identity == identity && key.status == status))\n  action.forEach(([key,value])=>value.call(this))\n}这样写已经能满足日常需求了，但认真一点讲，上面重写了4次functionA还是有点不爽，假如判断条件变得特别复杂，比如identity有3种状态，status有10种状态，那你需要定义30条处理逻辑，而往往这些逻辑里面很多都是相同的，这似乎也是笔者不想接受的，那可以这样实现:const actions = ()=>{\n  const functionA = ()=>{/*do sth*/}\n  const functionB = ()=>{/*do sth*/}\n  return new Map([\n    [/^guest_[1-4]$/,functionA],\n    [/^guest_5$/,functionB],\n    //...\n  ])\n}\n\nconst onButtonClick = (identity,status)=>{\n  let action = [...actions()].filter(([key,value])=>(key.test(`${identity}_${status}`)))\n  action.forEach(([key,value])=>value.call(this))\n}这里Map的优势更加凸显，可以用正则类型作为key了，这样就有了无限可能，假如需求变成，凡是guest情况都要发送一个日志埋点，不同status情况也需要单独的逻辑处理，那我们可以这样写:const actions = ()=>{\n  const functionA = ()=>{/*do sth*/}\n  const functionB = ()=>{/*do sth*/}\n  const functionC = ()=>{/*send log*/}\n  return new Map([\n    [/^guest_[1-4]$/,functionA],\n    [/^guest_5$/,functionB],\n    [/^guest_.*$/,functionC],\n    //...\n  ])\n}\n\nconst onButtonClick = (identity,status)=>{\n  let action = [...actions()].filter(([key,value])=>(key.test(`${identity}_${status}`)))\n  action.forEach(([key,value])=>value.call(this))\n}也就是说利用数组循环的特性，符合正则条件的逻辑都会被执行，那就可以同时执行公共逻辑和单独逻辑，因为正则的存在，你可以打开想象力解锁更多的玩法，本文就不赘述了。总结本文已经教你了8种逻辑判断写法，包括：if/elseswitch一元判断时：存到Object里一元判断时：存到Map里多元判断时：将condition拼接成字符串存到Object里多元判断时：将condition拼接成字符串存到Map里多元判断时：将condition存为Object存到Map里多元判断时：将condition写作正则存到Map里至此，本文也将告一段落，愿你未来的人生里，不只是有if/else/switch。\n            "},{"article_title":"css多行文本截断","description":"css多行文本截断 ...","mate":"2 年前","tags":["WEB技术","相关技术","黑科技"],"content":"\n                \n做响应式系统设计的时候遇到需要对标题进行多行文字截取的效果\n\n\n\n\n看似十分简单的标题截断效果，但是竟然没有一个统一 CSS 属性实现标准，需要用到一些奇淫妙计来实现，一般来说，在做这样文字截断效果时我们更多是希望：\n\n\n兼容性好，对各大主流浏览器有好的支持\n响应式截断，根据不同宽度做出调整\n文本超出范围才显示省略号，否则不显示省略号\n省略号位置显示刚好\n\n\n单行文本截断 text-overflow\n文本溢出我们经常用到的应该就是 text-overflow:ellipsis 了，相信大家也很熟悉，只需轻松几行代码就可以实现单行文本截断。\n\ndiv {\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n实现效果：\n\n\n属性浏览器原生支持，各大浏览器兼容性好，缺点就是只支持单行文本截断，并不支持多行文本截取。\n适用场景：单行文字截断最简单实现，效果最好，放心使用。\n如果是多行文字截取效果，实现起来就没有那么轻松。\n-webkit-line-clamp 实现\n先介绍第一种方式，就是通过 -webkit-line-clamp 属性实现。具体的方式如下：\ndiv {\n    display: -webkit-box;\n    overflow: hidden;\n    -webkit-line-clamp: 2;\n    -webkit-box-orient: vertical;\n}\n它需要和 display、 -webkit-box-orient 和 overflow 结合使用:\n*display:-webkit-box; 必须结合的属性，将对象作为弹性伸缩盒子模型显示。                  -webkit-box-orient; 必须结合的属性，设置或检索伸缩盒对象的子元素的排列方式。            text-overflow:ellipsis; 可选属性，可以用来多行文本的情况下，用省略号“…”隐藏超出范围的文本。  *\n实现效果：\n\n\n从效果上来看，它的优点有：\n\n响应式截断，根据不同宽度做出调整。\n文本超出范围才显示省略号，否则不显示省略号。\n浏览器原生实现，所以省略号位置显示刚好。\n\n但是缺点也是很直接，因为 -webkit-line-clamp 是一个不规范的属性，它没有出现在 CSS 规范草案中。也就是说只有 webkit 内核的浏览器才支持这个属性，像 Firefox, IE 浏览器统统都不支持这个属性，浏览器兼容性不好。\n使用场景：多用于移动端页面，因为移动设备浏览器更多是基于 webkit 内核，除了兼容性不好，实现截断的效果不错。\n定位元素实现多行文本截断\n另外还有一种靠谱简单的做法就是设置相对定位的容器高度，用包含省略号(…)的元素模拟实现，实现方式如下：\np {\n    position: relative;\n    line-height: 18px;\n    height: 36px;\n    overflow: hidden;\n}\n\np::after {\n    content: \"...\";\n    font-weight: bold;\n    position: absolute;\n    bottom: 0;\n    right: 0;\n    padding: 0 20px 1px 45px;\n    /* 为了展示效果更好 */\n    background: -webkit-gradient(linear, left top, right top, from(rgba(255, 255, 255, 0)), to(white), color-stop(50%, white));\n    background: -moz-linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white);\n    background: -o-linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white);\n    background: -ms-linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white);\n    background: linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white);\n}\n实现原理很好理解，就是通过伪元素绝对定位到行尾并遮住文字，再通过 overflow:hidden隐藏多余文字。\n实现效果：\n\n\n从实现效果来看，它所具备的优点：\n\n兼容性好，对各大主流浏览器有好的支持\n响应式截断，根据不同宽度做出调整\n\n但是它无法识别文字的长短，即文本超出范围才显示省略号，否则不显示省略号。还有因为是我们人为地在文字末尾添加一个省略号效果，就会导致它跟文字其实没有贴合的很紧密，遇到这种情况可以通过添加 word-break:break-all; 使一个单词能够在换行时进行拆分。\n适合场景：文字内容较多，确定文字内容一定会超过容器的，那么选择这种方式不错。\nfloat 特性实现多行文本截断\n回到一开始我要做的内容是多行标题文字截取效果，显然是无法控制标题的长度的，显然是无法使用上述的方式。回到事情的本质来看：我们希望 CSS 能够有一种属性，能够在文字溢出的情况下显示省略号，不溢出时不显示省略号(两种形式，两种效果)。\n正当我以为 CSS 已经无能为力，只能通过 JS 去实现的时候，后来看到了一个方法非常巧妙，而且能够满足上述提到的所有准则，下面我就介绍如何通过 float 特性实现多行文本截断效果。\n基本原理：\n\n\n有个三个盒子 div，粉色盒子左浮动，浅蓝色盒子和黄色盒子右浮动：\n\n\n当浅蓝色盒子的高度低于粉色盒子，黄色盒子仍会处于浅蓝色盒子右下方。\n如果浅蓝色盒子文本过多，高度超过了粉色盒子，则黄色盒子不会停留在右下方，而是掉到了粉色盒子下。\n好了，这样两种状态的两种展示形式已经区分开了，那么我们可以将黄色盒子进行相对定位，将内容溢出的黄色盒子移动到文本内容右下角，而未溢出的则会被移到外太空去了，只要我们使用 overflow:hidden就可以隐藏掉。\n\n\n基本原理就是这样，我们可以将浅蓝色区域想象成标题，黄色区域想象为省略号效果。那么你可能会觉得粉色盒子占了空间，那岂不是标题会整体延后了吗，这里可以通过 margin 的负值来出来，设置浅蓝色盒子的 margin-left 的负值与粉色盒子的宽度相同，标题也能正常显示。\n那么我们将前面的 DOM 结构简化下，变成下面这样：\n<div class=\"wrap\">\n    <div class=\"text\">Lorem ipsum dolor sit amet, consectetur adipisicing elit. Dignissimos labore sit vel itaque delectus atque quos magnam assumenda quod architecto perspiciatis animi.\n    </div>\n</div>    刚才的粉色盒子和黄色盒子都可以用伪元素来代替。\n.wrap {\n    height: 40px;\n    line-height: 20px;\n    overflow: hidden;\n}\n.wrap .text {\n    float: right;\n    margin-left: -5px;\n    width: 100%;\n    word-break: break-all;\n}\n.wrap::before {\n    float: left;\n    width: 5px;\n    content: '';\n    height: 40px;\n}\n.wrap::after {\n    float: right;\n    content: \"...\";\n    height: 20px;\n    line-height: 20px;  /* 为三个省略号的宽度 */  width: 3em;  /* 使盒子不占位置 */\n    margin-left: -3em;  /* 移动省略号位置 */\n    position: relative;\n    left: 100%;\n    top: -20px;\n    padding-right: 5px;\n}\n这里我目前看到最巧妙的方式了。只需要支持 CSS 2.1 的特性就可以了，它的优点有:\n\n兼容性好，对各大主流浏览器有好的支持。\n响应式截断，根据不同宽度做出调整。\n文本超出范围才显示省略号，否则不显示省略号。\n\n\n最后用预编译工具scss改进一下写法\n\n@mixin ellipsis($height, $lineHeight, $openWidth, $fontSize) {\n    height: $height;\n    line-height: $lineHeight;\n    overflow: hidden;\n    text-align: justify;\n\n    &::before {\n        float: left;\n        width: 5px;\n        content: '';\n        height: $height;\n    }\n\n    &::after {\n        float: right;\n        color: #999;\n        content: \"...\";\n        height: $lineHeight;\n        font-size: $fontSize;\n        line-height: $lineHeight;\n        padding-right: 5px;\n        text-align: right;\n        width: $openWidth;\n        margin-left: -($openWidth);\n        position: relative;\n        left: 100%;\n        top: -$lineHeight;\n        padding-right: 5px;\n        background: linear-gradient(to right, rgba(255, 255, 255, 0), white 50%, white);\n        box-sizing: content-box;\n    }\n\n    .text {\n        color: inherit;\n        font-size: inherit;\n        float: right;\n        margin-left: -5px;\n        width: 100%;\n        word-break: break-all;\n    }\n}\n用到地方用include导入一下\n对了至于缺点，因为我们是模拟省略号，所以显示位置有时候没办法刚刚好，所以可以考虑加一个渐变效果，贴合文字，就像上述 demo 效果一样。\n添加 word-break:break-all; 使一个单词能够在换行时进行拆分，这样文字和省略号贴合效果更佳。\n这个方法应该是我看到最好的用纯 CSS 处理的方式了，如果你有更好的方法，欢迎留言交流！\n\n            "},{"article_title":"ejs模板的书写","description":"1、EJS是一个简单高效的模板语言，通过数据和模板，可以生成HTML标记文本。可以说EJS是一个JavaScript库，EJS可以同时运行在客户端和服务器端，客户端安装直接引入文件即可，服务器端用 ...","mate":"2 年前","tags":["WEB技术","相关技术"],"content":"\n                \n        \n        \n          \n           \n1、EJS是一个简单高效的模板语言，通过数据和模板，可以生成HTML标记文本。可以说EJS是一个JavaScript库，EJS可以同时运行在客户端和服务器端，客户端安装直接引入文件即可，服务器端用npm包安装\n2、EJS的特点：\n\n快速编译和渲染\n简单的模板标签\n自定义标记分隔符\n支持文本包含\n支持浏览器端和服务器端\n模板静态缓存\n支持express视图系统\n\n3、EJS成员函数：\n\nRender(str,data,[option]):直接渲染字符串并生成html\nstr：需要解析的字符串模板\ndata：数据\noption：配置选项\nCompile(str,[option]):编译字符串得到模板函数\nstr：需要解析的字符串模板\noption：配置选项\n\n两个函数包括的配置选项如下：\n\n\n\n\n\n\n\n4、EJS常用标签\n\n<% %>流程控制标签\n<%= %>输出标签（原文输出HTML标签）\n<%- %>输出标签（HTML会被浏览器解析）\n<%# %>注释标签\n% 对标记进行转义\n-%>去掉没用的空格\n说明：ejs中的逻辑代码全部用JavaScript\n\n5、接下来看一个例子就可以明白EJS的简单语法了\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n<title>EJS Examples</title>\n<meta name=\"description\" content=\"\">\n<meta name=\"keywords\" content=\"\">\n<link href=\"\" rel=\"stylesheet\">\n<script type=\"text/javascript\" src=\"ejs.min.js\"></script>\n<script >\n    var data={flag:false,\n                data1:[\"====1\",\"====2\",\"====3\"],\n                data2:[\"====4\",\"====5\",\"====6\"]\n            };\n\n    window.onload=function(){\n        var tem=document.getElementById(\"tem\").innerHTML;\n        var html=ejs.render(tem,data);\n        document.getElementsByTagName(\"body\")[0].innerHTML=html;\n    }\n</script>\n</head>\n<body>\n<script type=\"text/javascript\" id=\"tem\">\n<ul>\n    <%if(flag){%>\n      <%for (var i=0;i<data1.length;i++){%>\n      <li><%=data1[i]%></li>\n      <%}%>\n      <%}else{%>\n        <%for(var i=0;i<data2.length;i++){%>\n        <li><%=data2[i]%></li>\n        <%}%>\n        <%}%>\n      </ul>\n</script>\n</body>\n</html>\n\n运行后结果如下：\n\n\n\n\n\n\n\n4、过滤器（把结果进一步加工的函数）：\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n语法如下：\n<%=: data.age | plus:5%>\n\n注意:和|两个符号:\n此外，还有文件包含的语法：\n<%- include(path) %>\n\n接下来用这个写一个服务器端的，文件目录如下：\n\n\n\n\n\n\napp.js文件内容如下：\n\nvar http=require(\"http\");\nvar express=require(\"express\");\nvar app=express();\n\nvar tem={\n    message:\"我是中间部分\"\n}\n//创建服务器\nhttp.createServer(app).listen(3000,function(){\n    console.log(\"Server is listening port 3000\");\n});\n//挂载静态资源处理中间件\napp.use(express.static(__dirname+\"/public\"));\n//设置模板视图的目录\napp.set(\"views\",\"./public/views\");\n//设置是否启用视图编译缓存，启用将加快服务器执行效率\napp.set(\"view cache\",true);\n//设置模板引擎的格式即运用何种模板引擎\napp.set(\"view engine\",\"ejs\");\n//设置路由\napp.get(\"/ejs\",function(req,res){\n    res.render(\"ejs1\",{title:tem.message});\n});\n\nejs1.ejs文件内容如下这里引用了头部和尾部：\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n<title>EJS</title>\n<meta name=\"description\" content=\"\">\n<meta name=\"keywords\" content=\"\">\n<link href=\"../css/main.css\" rel=\"stylesheet\">\n</head>\n<body>\n<%- include(\"./header.ejs\") %>\n    <h1><%=title%></h1>\n    <%- include(\"./footer.ejs\") %>\n</body>\n</html>\n\n头部和尾部都是一行代码如下：\n<h1>我是头部</h1>\n<h1>我是尾部</h1>\n\n启动服务器后，我们输入http://localhost:3000/ejs，显示内容如下：\n\n\n\n\n\n\n这说明我们利用ejs模板做到了正确输出，这既可以大大增加代码的复用性，而且当data为数据库中的数据时，我们就可以做到实时更新网站数据了，这样一个简单动态网站就完成了，听起来是不是很简单，不过还有很长一段路要走滴，先睡了，下次再更。\n\n\n          \n        \n    \n            "},{"article_title":"Webpack4.x配置多入口多出口项目","description":"在目录下创建src目录,使用npm init -y 生成package.json依赖模块文件,我们把执行命令放在script里面,这样我们只要执行npm run build就可以了. { \"name\": \"webpack4\", ...","mate":"2 年前","tags":["WEB技术","相关技术"],"content":"\n                \n在目录下创建src目录,使用npm init -y 生成package.json依赖模块文件,我们把执行命令放在script里面,这样我们只要执行npm run build就可以了.\n\n{\n  \"name\": \"webpack4\",\n  \"version\": \"1.0.0\",\n  \"description\": \"\",\n  \"main\": \"webpack.config.js\",\n  \"scripts\": {\n    \"build\": \"webpack --mode development\"\n  },\n  \"author\": \"\",\n  \"license\": \"ISC\"\n}\n在目录下在创建一个dist目录,里面写个index.html文件\n<!DOCTYPE html>\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n    <script type=\"text/javascript\" src=\"bundle.js\"></script>\n</body>\n</html>\n在src下创建一个index.js文件\ndocument.write('welcome suzhou');\n创建 webpack.config.json文件\nconst path = require('path');\n\nmodule.exports = {\n    entry:'./src/index.js',\n    output:{\n        path:path.resolve(__dirname,'dist'),\n        filename:'bundle.js' // 表示输出的js文件名\n    }\n}\n这时只要运行一下 npm run build 就可以打包出bundle.js了.\nJS多入口(打包到一起,也就是多对一打包)\n这时候我们在以上项目目录的基础上,在src下增加一个index2.js文件\ndocument.write('welcome Strive');\n我们在编写webpack.config.js,entry入口是支持数组的,而且打包是按数组由前向后打包的。\nconst path = require('path');\n\nmodule.exports = {\n    entry:['./src/index.js','./src/index2.js'],\n    output:{\n        path:path.resolve(__dirname,'dist'),\n        filename:'bundle.js' //名字可以随便起\n    }\n};\n这时候我们只要在执行 npm run build 就可以了.\nJS多入口多出口?也就是多对多的实现.\n我们继续来编写webpack.config.js\nconst path = require('path');\n\nmodule.exports = {\n    entry:{ //entry入口文件支持json的形式\n        index: './src/index.js',\n        index2: './src/index2.js'\n    },\n    output:{\n        path:path.resolve(__dirname,'dist'),\n        //filename前面我们可以使用一个变量[name],这个就表示获取entry里面的key作为文件名加在前面\n        //打出来是index-bundle.js\n        //和index2-bundle.js\n        filename:'[name]-bundle.js'\n    }\n}\n这时运行 npm run build ,这时dist里面打包出来的就是index-bundle.js和index2-bundle.js了.\n\n如何使html自动引入js文件?\n\n这时候我们想到了每次向html中手动引入script文件太麻烦,如何让它自动引入呢?这时候我们想到了webpack的plugins插件.\n首先我们要使用的是html-webpack-plugin插件,这个插件的注意功能就是生成页面.\n\n安装html-webpack-plugin插件,因为是开发的时候需要,所以在后面加-D\n\n而这个插件是依赖webpack和webpack-cli的,所以我们先将webpack和webpack-cli下载到本地\ncnpm i webpack@4.1.0 -D\n\ncnpm i webpack-cli -D\n\ncnpm i html-webpack-plugin -D\n\n安装成功以后,在webpack.config.js里面引入\n\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\n在webpack.config.js里面的plugins里面配置插件\n\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\nmodule.exports = {\n    entry:{\n        index: './src/index.js',\n        index2: './src/index2.js'\n    },\n    output:{\n        path:path.resolve(__dirname,'dist'),\n        //filename前面我们可以使用一个变量[name],这个就表示获取entry里面的key作为文件名加在前面\n        //打出来是index-bundle.js\n        //和index2-bundle.js\n        filename:'[name]-bundle.js'\n    },\n    plugins:[\n        new HtmlWebpackPlugin()\n    ]\n}\n这时我们就可以执行 npm run build 了.\n我们发现自动创建了dist目录,里面有index.html,index-bundle.js,index2-bundle.js目录,并且index.html自动引入了index-bundle.js,index2-bundle.js文件.\nhtml-webpack-plugin插件配置模板HTML文件\n我们在src下写一个index.html模板文件\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    entry:{\n        index: './src/index.js',\n        index2: './src/index2.js'\n    },\n    output:{\n        path:path.resolve(__dirname,'dist'),\n        //filename前面我们可以使用一个变量[name],这个就表示获取entry里面的key作为文件名加在前面\n        //打出来是index-bundle.js\n        //和index2-bundle.js\n        filename:'[name]-bundle.js'\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            template: './src/index.html' //模板地址\n\n        })\n    ]\n}\n这个时候我们再运行npm run build,我发现自动生成了dist目录,里面的index是我们先前在src里面写的模板文件,并且自动引入了js文件.\n自动配置页面title\n如果配置了title,一定要在模板html中使用\n<title><%= htmlWebpackPlugin.options.title%></title>\n- index.html\n\n// index.html模板\n<!DOCTYPE html>\n<html>\n<head>\n    <title><%= htmlWebpackPlugin.options.title%></title>\n</head>\n<body>\n    <div id=\"root\"></div>\n</body>\n</html>\n\n如何自动消除src引入的缓存问题?\n\n自动引入的src链接，如何消除消除缓存呢?我们只要在html-webpack-plugin配置中增加一个hash为true的配置,它就会自动在引入的src地址后面增加一段hash值\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    entry:{\n        index: './src/index.js',\n        index2: './src/index2.js'\n    },\n    output:{\n        path:path.resolve(__dirname,'dist'),\n        //filename前面我们可以使用一个变量[name],这个就表示获取entry里面的key作为文件名加在前面\n        //打出来是index-bundle.js\n        //和index2-bundle.js\n        filename:'[name]-bundle.js'\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            hash:true, //向html引入的src链接后面增加一段hash值,消除缓存\n            title:'I love China',\n            template: './src/index.html' //模板地址\n        })\n    ]\n}\n\n那么我们要上线之前是要压缩输出的，如何操作呢?\n\n我们需要向html-webpack-plugin插件中配置minify压缩代码\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    entry:{\n        index: './src/index.js',\n        index2: './src/index2.js'\n    },\n    output:{\n        path:path.resolve(__dirname,'dist'),\n        //filename前面我们可以使用一个变量[name],这个就表示获取entry里面的key作为文件名加在前面\n        //打出来是index-bundle.js\n        //和index2-bundle.js\n        filename:'[name]-bundle.js'\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            minify:{\n                collapseWhitespace:true //折叠空白区域 也就是压缩代码\n            },\n            hash:true,\n            title:'I love China',\n            template: './src/index.html' //模板地址\n        })\n    ]\n}\n多个HTML模板区分输出配置\n\n那么要是我们多个html模板文件,如何区分开生成多个页面呢？\n\n只要以链式的方法,再调用一次html-webpack-plugin插件,每次调用都要指定filename也就是生成页面的名字.调用一次生成一个页面,调用两次生成两个页面,以此类推.\n比如说我们在src下在创建一个index2.html模板文件\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    entry:{\n        index: './src/index.js',\n        index2: './src/index2.js'\n    },\n    output:{\n        path:path.resolve(__dirname,'dist'),\n        //filename前面我们可以使用一个变量[name],这个就表示获取entry里面的key作为文件名加在前面\n        //打出来是index-bundle.js\n        //和index2-bundle.js\n        filename:'[name]-bundle.js'\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            filename:'index.html', //每次调用指定生成的html名称\n            minify:{\n                collapseWhitespace:true //折叠空白区域 也就是压缩代码\n            },\n            hash:true,\n            title:'I love China',\n            template: './src/index.html' //模板地址\n        }),\n        new HtmlWebpackPlugin({\n            filename:'index2.html', //每次调用指定生成的html名称\n            minify:{\n                collapseWhitespace:true //折叠空白区域 也就是压缩代码\n            },\n            hash:true,\n            title:'第二个页面',\n            template: './src/index2.html' //模板地址\n        })\n    ]\n}\n生成的HTML文件引入各自的JS文件配置\n\n那么我们生成多个html文件的时候,我们希望各自引入各自的js文件,那么如何操作呢?\n\n比如说我们希望index.html引入的是index-bundle.js， index2.html引入的是index2-bundle.js如何操作呢?\n我们需要在html-webpack-plugin中再配置一个参数,chunks,支持数组,数组里面填写的是引入的js,也就是entry里面配置的key,要引入哪个js就配置entry中的哪个key.\nconst path = require('path');\nconst HtmlWebpackPlugin = require('html-webpack-plugin');\n\nmodule.exports = {\n    entry:{\n        index: './src/index.js',\n        index2: './src/index2.js'\n    },\n    output:{\n        path:path.resolve(__dirname,'dist'),\n        //filename前面我们可以使用一个变量[name],这个就表示获取entry里面的key作为文件名加在前面\n        //打出来是index-bundle.js\n        //和index2-bundle.js\n        filename:'[name]-bundle.js'\n    },\n    plugins:[\n        new HtmlWebpackPlugin({\n            chunks:['index'], //添加引入的js,也就是entry中的key\n            filename:'index.html',\n            minify:{\n                collapseWhitespace:true //折叠空白区域 也就是压缩代码\n            },\n            hash:true,\n            title:'I love China',\n            template: './src/index.html' //模板地址\n        }),\n        new HtmlWebpackPlugin({\n            chunks:['index2'], //添加引入的js,也就是entry中的key\n            filename:'index2.html',\n            minify:{\n                collapseWhitespace:true //折叠空白区域 也就是压缩代码\n            },\n            hash:true,\n            title:'第二个页面',\n            template: './src/index2.html' //模板地址\n        })\n    ]\n}\n这个时候我们在执行npm run build,index.html和index2.html分别引入了自己的js文件\n\n            "},{"article_title":"如何封装并发布自己的npm包","description":"最近很多人问我,如何取封装自己的npm工具包,直接用npm安装,省时又省力.关键支持三种引用方式(amd,cmd和直接引入),下面就教大家如何去封装自己的应用工具包. * 首先先去[npm官网](https://www.npmjs.com/)注册一个自己的账号,有了自己的账号才 ...","mate":"2 年前","tags":["WEB技术","相关技术"],"content":"\n                最近很多人问我,如何取封装自己的npm工具包,直接用npm安装,省时又省力.关键支持三种引用方式(amd,cmd和直接引入),下面就教大家如何去封装自己的应用工具包.\n* 首先先去[npm官网](https://www.npmjs.com/)注册一个自己的账号,有了自己的账号才能在将你的插件代码放在npm仓库中.\n* 电脑需要node环境支持并且有npm包管理工具 \n\n有了自己的账号下面就开始实践操作吧!\n第一步\n首先登陆npm\n\nnpm login\n出现下图则证明登陆成功\n\n\n第二步\n创建一个文件夹去存放一会将要写的插件,文件夹的名字叫做npmDemo\n\nmkdir npmDemo\n\n\n            "}]