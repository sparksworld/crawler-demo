[{"article_title":"vue3.0之前TypeScript 最佳入门实践","description":"TypeScript 最佳入门实践 其实Vue官方从2.6.X版本开始就部分使用Ts重写了。 注意此篇标题的“前”，本文旨在讲Ts混入框架的使用，不讲Class API ...","mate":"1 年前","tags":["相关技术","WEB技术"],"content":"\n                前言其实Vue官方从2.6.X版本开始就部分使用Ts重写了。注意此篇标题的“前”，本文旨在讲Ts混入框架的使用，不讲Class API1. 使用官方脚手架构建npm install -g @vue/cli\n# OR\nyarn global add @vue/cli新的Vue CLI工具允许开发者 使用 TypeScript 集成环境 创建新项目。只需运行vue create my-app。然后，命令行会要求选择预设。使用箭头键选择Manually select features。接下来，只需确保选择了TypeScript和Babel选项，如下图：完成此操作后，它会询问你是否要使用class-style component syntax。然后配置其余设置，使其看起来如下图所示。Vue CLI工具现在将安装所有依赖项并设置项目。接下来就跑项目喇。总之，先跑起来再说。2. 项目目录解析通过tree指令查看目录结构后可发现其结构和正常构建的大有不同。这里主要关注shims-tsx.d.ts和 shims-vue.d.ts两个文件两句话概括：shims-tsx.d.ts，允许你以.tsx结尾的文件，在Vue项目中编写jsx代码shims-vue.d.ts  主要用于 TypeScript 识别.vue 文件，Ts默认并不支持导入 vue 文件，这个文件告诉ts 导入.vue 文件都按VueConstructor<Vue>处理。此时我们打开亲切的src/components/HelloWorld.vue，将会发现写法已大有不同<template>\n  <div class=\"hello\">\n    <h1>{{ msg }}</h1>\n    <!-- 省略 -->\n  </div>\n</template>\n<script lang=\"ts\">\nimport { Component, Prop, Vue } from 'vue-property-decorator';\n@Component\nexport default class HelloWorld extends Vue {\n@Prop() private msg!: string;\n}\n</script>至此，准备开启新的篇章 TypeScript极速入门 和 vue-property-decorator3. TypeScript极速入门3.1 基本类型和扩展类型Typescript与Javascript共享相同的基本类型，但有一些额外的类型。元组 Tuple枚举 enumAny 与Void1. 基本类型合集// 数字，二、八、十六进制都支持\nlet decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\n// 字符串，单双引都行\nlet name: string = \"bob\";\nlet sentence: string = `Hello, my name is ${ name }.\n// 数组，第二种方式是使用数组泛型，Array<元素类型>：\nlet list: number[] = [1, 2, 3];\nlet list: Array<number> = [1, 2, 3];\nlet u: undefined = undefined;\nlet n: null = null;2. 特殊类型1. 元组 Tuple想象 元组 作为有组织的数组，你需要以正确的顺序预定义数据类型。const messyArray = [' something', 2, true, undefined, null];\nconst tuple: [number, string, string] = [24, \"Indrek\" , \"Lasn\"]如果不遵循 为元组 预设排序的索引规则，那么Typescript会警告。​     （tuple第一项应为number类型）2. 枚举 enumenum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。// 默认情况从0开始为元素编号，也可手动为1开始\nenum Color {Red = 1, Green = 2, Blue = 4}\nlet c: Color = Color.Green;另一个很好的例子是使用枚举来存储应用程序状态。3. Void在Typescript中，你必须在函数中定义返回类型。像这样：若没有返回值，则会报错：我们可以将其返回值定义为void:此时将无法 return4. AnyEmmm...就是什么类型都行，当你无法确认在处理什么类型时可以用这个。但要慎重使用，用多了就失去使用Ts的意义。let person: any = \"前端劝退师\"\nperson = 25\nperson = true主要应用场景有：接入第三方库Ts菜逼前期都用5. Never用很粗浅的话来描述就是：\"Never是你永远得不到的爸爸。\"具体的行为是：throw new Error(message)return error(\"Something failed\")while (true) {} // 存在无法达到的终点3. 类型断言简略的定义是：可以用来手动指定一个值的类型。有两种写法，尖括号和as:let someValue: any = \"this is a string\";使用例子有：当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：function getLength(something: string | number): number {\n    return something.length;\n}如果你访问长度将会报错，而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，此时需要断言才不会报错：function getLength(something: string | number): number {\n    if ((<string>something).length) {\n        return (<string>something).length;\n    } else {\n        return something.toString().length;\n    }\n}3.2  泛型：Generics软件工程的一个主要部分就是构建组件，构建的组件不仅需要具有明确的定义和统一的接口，同时也需要组件可复用。支持现有的数据类型和将来添加的数据类型的组件为大型软件系统的开发过程提供很好的灵活性。在C#和Java中，可以使用\"泛型\"来创建可复用的组件，并且组件可支持多种数据类型。这样便可以让用户根据自己的数据类型来使用组件。1. 泛型方法在TypeScript里，声明泛型方法有以下两种方式：function gen_func1<T>(arg: T): T {\n    return arg;\n}\n// 或者\nlet gen_func2: <T>(arg: T) => T = function (arg) {\n    return arg;\n}调用方式也有两种：gen_func1<string>('Hello world');\ngen_func2('Hello world');\n// 第二种调用方式可省略类型参数，因为编译器会根据传入参数来自动识别对应的类型。2. 泛型与AnyTs 的特殊类型 Any 在具体使用时，可以代替任意类型，咋一看两者好像没啥区别，其实不然：// 方法一：带有any参数的方法\nfunction any_func(arg: any): any {\n    console.log(arg.length);\n\t\treturn arg;\n}方法一，打印了arg参数的length属性。因为any可以代替任意类型，所以该方法在传入参数不是数组或者带有length属性对象时，会抛出异常。方法二，定义了参数类型是Array的泛型类型，肯定会有length属性，所以不会抛出异常。3. 泛型类型泛型接口：interface Generics_interface<T> {\n    (arg: T): T;\n}\nfunction func_demo<T>(arg: T): T {\nreturn arg;\n}3.3  自定义类型：Interface vs Type aliasInterface，国内翻译成接口。Type alias，类型别名。以下内容来自：Typescript 中的 interface 和 type 到底有什么区别1. 相同点都可以用来描述一个对象或函数：interface User {\n  name: string\n  age: number\n}\ntype User = {\nname: string\nage: number\n};\ninterface SetUser {\n(name: string, age: number): void;\n}\ntype SetUser = (name: string, age: number): void;都允许拓展（extends）：interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说interface可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。interface extends interfaceinterface Name {\n  name: string;\n}\ninterface User extends Name {\n  age: number;\n}type extends typetype Name = {\n  name: string;\n}\ntype User = Name & { age: number  };interface extends typetype Name = {\n  name: string;\n}\ninterface User extends Name {\n  age: number;\n}type extends interfaceinterface Name {\n  name: string;\n}\ntype User = Name & {\n  age: number;\n}2. 不同点type 可以而 interface 不行type 可以声明基本类型别名，联合类型，元组等类型// 基本类型别名\ntype Name = string\n// 联合类型\ninterface Dog {\nwong();\n}\ninterface Cat {\nmiao();\n}\ntype Pet = Dog | Cattype 语句中还可以使用 typeof获取实例的 类型进行赋值// 当你想获取一个变量的类型时，使用 typeof\nlet div = document.createElement('div');\ntype B = typeof div其他骚操作type StringOrNumber = string | number;\ntype Text = string | { text: string };\ntype NameLookup = Dictionary<string, Person>;\ntype Callback<T> = (data: T) => void;\ntype Pair<T> = [T, T];\ntype Coordinates = Pair<number>;\ntype Tree<T> = T | { left: Tree<T>, right: Tree<T> };interface可以而 type不行interface 能够声明合并interface User {\n  name: string\n  age: number\n}\ninterface User {\nsex: string\n}\n/*\nUser 接口为 {\nname: string\nage: number\nsex: string\n}\n*/interface 有可选属性和只读属性可选属性接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 例如给函数传入的参数对象中只有部分属性赋值了。带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。如下所示interface Person {\n  name: string;\n  age?: number;\n  gender?: number;\n}只读属性顾名思义就是这个属性是不可写的，对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性，如下所示：interface User {\n    readonly loginName: string;\n    password: string;\n}上面的例子说明，当完成User对象的初始化后loginName就不可以修改了。3.4 实现与继承：implementsvsextendsextends很明显就是ES6里面的类继承，那么implement又是做什么的呢？它和extends有什么不同？implement，实现。与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约implement基本用法：interface IDeveloper {\n   name: string;\n   age?: number;\n}\n// OK\nclass dev implements IDeveloper {\n    name = 'Alex';\n    age = 20;\n}\n// OK\nclass dev2 implements IDeveloper {\n    name = 'Alex';\n}\n// Error\nclass dev3 implements IDeveloper {\n    name = 'Alex';\n    age = '9';\n}而extends是继承父类，两者其实可以混着用：class A extends B implements C,D,E搭配 interface和type的用法有：3.5 声明文件与命名空间：declare 和 namespace前面我们讲到Vue项目中的shims-tsx.d.ts和shims-vue.d.ts，其初始内容是这样的：// shims-tsx.d.ts\nimport Vue, { VNode } from 'vue';\ndeclare global {\nnamespace JSX {\n// tslint:disable no-empty-interface\ninterface Element extends VNode {}\n// tslint:disable no-empty-interface\ninterface ElementClass extends Vue {}\ninterface IntrinsicElements {\n[elem: string]: any;\n}\n}\n}\n// shims-vue.d.ts\ndeclare module '*.vue' {\nimport Vue from 'vue';\nexport default Vue;\n}declare：当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。这里列举出几个常用的：declare var 声明全局变量\ndeclare function 声明全局方法\ndeclare class 声明全局类\ndeclare enum 声明全局枚举类型\ndeclare global 扩展全局变量\ndeclare module 扩展模块namespace：“内部模块”现在称做“命名空间”module X { 相当于现在推荐的写法 namespace X {)跟其他 JS 库协同类似模块，同样也可以通过为其他 JS 库使用了命名空间的库创建 .d.ts 文件的声明文件，如为 D3 JS 库，可以创建这样的声明文件：declare namespace D3{\n    export interface Selectors { ... }\n}\ndeclare var d3: D3.Base;所以上述两个文件：shims-tsx.d.ts， 在全局变量 global中批量命名了数个内部模块。shims-vue.d.ts，意思是告诉 TypeScript *.vue 后缀的文件可以交给 vue 模块来处理。3.6 访问修饰符：private、public、protected其实很好理解：默认为public当成员被标记为private时，它就不能在声明它的类的外部访问，比如：class Animal {\n    private name: string;\n    constructor(theName: string) {\n        this.name = theName;\n    }\n}protected和private类似，但是，protected成员在派生类中可以访问class Animal {\n    protected name: string;\n    constructor(theName: string) {\n        this.name = theName;\n    }\n}3.7 可选参数 ( ?: )和非空断言操作符（!.）可选参数function buildName(firstName: string, lastName?: string) {\n    return firstName + ' ' + lastName\n}非空断言操作符：能确定变量值一定不为空时使用。与可选参数 不同的是，非空断言操作符不会防止出现 null 或 undefined。let s = e!.name;  // 断言e是非空并访问name属性4. Vue组件的Ts写法从 vue2.5 之后，vue 对 ts 有更好的支持。根据官方文档，vue 结合 typescript ，有两种书写方式：**Vue.extend **import Vue from 'vue'vue-class-componentimport { Component, Vue, Prop } from 'vue-property-decorator'\n\n@Component\nexport default class Test extends Vue {\n  @Prop({ type: Object })\n  private test: { value: string }\n}理想情况下，Vue.extend 的书写方式，是学习成本最低的。在现有写法的基础上，几乎 0 成本的迁移。但是Vue.extend模式，需要与mixins 结合使用。在 mixin 中定义的方法，不会被 typescript 识别到，这就意味着会出现丢失代码提示、类型检查、编译报错等问题。菜鸟才做选择，大佬都挑最好的。直接讲第二种吧：4.1 vue-class-component我们回到src/components/HelloWorld.vue<template>\n  <div class=\"hello\">\n    <h1>{{ msg }}</h1>\n    <!-- 省略 -->\n  </div>\n</template>\n<script lang=\"ts\">\nimport { Component, Prop, Vue } from 'vue-property-decorator';\n@Component\nexport default class HelloWorld extends Vue {\n@Prop() private msg!: string;\n}\n</script>有写过python的同学应该会发现似曾相识：vue-property-decorator这个官方支持的库里，提供了函数 **装饰器（修饰符）**语法1.  函数修饰符 @“@”，与其说是修饰函数倒不如说是引用、调用它修饰的函数。或者用句大白话描述：@: \"下面的被我包围了。\"举个栗子，下面的一段代码，里面两个函数，没有被调用，也会有输出结果：test(f){\n    console.log(\"before ...\");\n    f()\n\t\tconsole.log(\"after ...\");\n }直接运行，输出结果：before ...\nfunc was called\nafter ...上面代码可以看出来:只定义了两个函数：test和func，没有调用它们。如果没有“@test”，运行应该是没有任何输出的。但是，解释器读到函数修饰符“@”的时候，后面步骤会是这样：去调用test函数，test函数的入口参数就是那个叫“func”的函数；test函数被执行，入口参数的（也就是func函数）会被调用（执行）；换言之，修饰符带的那个函数的入口参数，就是下面的那个整个的函数。有点儿类似JavaScript里面的 function a (function () { ... });2. vue-property-decorator和vuex-class提供的装饰器vue-property-decorator的装饰器：@Prop@PropSync@Provide@Model@Watch@Inject@Provide@Emit@Component (provided by vue-class-component)Mixins (the helper function named mixins provided by vue-class-component)vuex-class的装饰器：@State@Getter@Action@Mutation我们拿原始Vue组件模版来看：import {componentA,componentB} from '@/components';以上模版替换成修饰符写法则是：import { Component, Vue, Prop } from 'vue-property-decorator';\nimport { State, Getter } from 'vuex-class';\nimport { count, name } from '@/person'\nimport { componentA, componentB } from '@/components';\n\n@Component({\n    components:{ componentA, componentB},\n})\nexport default class HelloWorld extends Vue{\n\t@Prop(Number) readonly propA!: number | undefined\n    @Prop({ default: 'default value' }) readonly propB!: string\n    @Prop([String, Boolean]) readonly propC!: string | boolean | undefined\n\n  // 原data\n  message = 'Hello'\n\n  // 计算属性\n\tprivate get reversedMessage (): string[] {\n  \treturn this.message.split('').reverse().join('')\n  }\n  // Vuex 数据\n  @State((state: IRootState) => state . booking. currentStep) step!: number\n\t@Getter( 'person/name') name!: name\n\n  // method\n  public changeMessage (): void {\n    this.message = 'Good bye'\n  },\n  public getName(): string {\n    let storeName = name\n    return storeName\n  }\n\t// 生命周期\n  private created ()：void { },\n  private mounted ()：void { },\n  private updated ()：void { },\n  private destroyed ()：void { }\n}正如你所看到的，我们在生命周期 列表那都添加private XXXX方法，因为这不应该公开给其他组件。而不对method做私有约束的原因是，可能会用到@Emit来向父组件传递信息。4.2 添加全局工具引入全局模块，需要改main.ts:import Vue from 'vue';\nimport App from './App.vue';\nimport router from './router';\nimport store from './store';\nVue.config.productionTip = false;npm i VueI18nimport Vue from 'vue';\nimport App from './App.vue';\nimport router from './router';\nimport store from './store';\n// 新模块\nimport i18n from './i18n';\n\nVue.config.productionTip = false;\n\nnew Vue({\n    router,\n    store,\n    i18n, // 新模块\n    render: (h) => h(App),\n}).$mount('#app');但仅仅这样，还不够。你需要动src/vue-shim.d.ts：// 声明全局方法\ndeclare module 'vue/types/vue' {\n  interface Vue {\n        readonly $i18n: VueI18Next;\n        $t: TranslationFunction;\n    }\n}之后使用this.$i18n()的话就不会报错了。4.3 Axios 使用与封装Axios的封装千人千面如果只是想简单在Ts里体验使用Axios，可以安装vue-axios简单使用Axios$ npm i axios vue-axios\n复制代码main.ts添加：import Vue from 'vue'\nimport axios from 'axios'\nimport VueAxios from 'vue-axios'然后在组件内使用：Vue.axios.get(api).then((response) => {\n  console.log(response.data)\n})\n\nthis.axios.get(api).then((response) => {\n  console.log(response.data)\n})\n\nthis.$http.get(api).then((response) => {\n  console.log(response.data)\n})1. 新建文件request.ts文件目录:-api\n    - main.ts   // 实际调用\n-utils\n    - request.ts  // 接口封装2. request.ts文件解析import * as axios from 'axios';\nimport store from '@/store';\n// 这里可根据具体使用的UI组件库进行替换\nimport { Toast } from 'vant';\nimport { AxiosResponse, AxiosRequestConfig } from 'axios';\n/* baseURL 按实际项目来定义 */\nconst baseURL = process.env.VUE_APP_URL;\n/* 创建axios实例 */\nconst service = axios.default.create({\nbaseURL,\ntimeout: 0, // 请求超时时间\nmaxContentLength: 4000,\n});\nservice.interceptors.request.use((config: AxiosRequestConfig) => {\nreturn config;\n}, (error: any) => {\nPromise.reject(error);\n});\nservice.interceptors.response.use(\n(response: AxiosResponse) => {\nif (response.status !== 200) {\nToast.fail('请求错误！');\n} else {\nreturn response.data;\n}\n},\n(error: any) => {\nreturn Promise.reject(error);\n});为了方便，我们还需要定义一套固定的 axios 返回的格式，新建ajax.ts：export interface AjaxResponse {\n    code: number;\n    data: any;\n    message: string;\n}3. main.ts接口调用：// api/main.ts\nimport request from '../utils/request';\n\n// get\nexport function getSomeThings(params:any) {\n    return request({\n        url: '/api/getSomethings',\n    });\n}\n\n// post\nexport function postSomeThings(params:any) {\n    return request({\n        url: '/api/postSomethings',\n        methods: 'post',\n        data: params\n    });\n}5. 编写一个组件为了减少时间，我们来替换掉src/components/HelloWorld.vue，做一个博客帖子组件：<template>\n\t<div class=\"blogpost\">\n\t\t<h2>{{ post.title }}</h2>\n\t\t<p>{{ post.body }}</p>\n\t\t<p class=\"meta\">Written by {{ post.author }} on {{ date }}</p>\n\t</div>\n</template>\n<script lang=\"ts\">\nimport { Component, Prop, Vue } from 'vue-property-decorator';\n// 在这里对数据进行类型约束\nexport interface Post {\ntitle: string;\nbody: string;\nauthor: string;\ndatePosted: Date;\n}\n@Component\nexport default class HelloWorld extends Vue {\n@Prop() private post!: Post;\nget <span class=\"hljs-function\"><span class=\"hljs-title\">date</span></span>() {\n\t<span class=\"hljs-built_in\">return</span> `<span class=\"hljs-variable\">${this.post.datePosted.getDate()}</span>/<span class=\"hljs-variable\">${this.post.datePosted.getMonth()}</span>/<span class=\"hljs-variable\">${this.post.datePosted.getFullYear()}</span>`;\n}\n\n}\n</script>然后在Home.vue中使用:<template>\n  <div class=\"home\">\n    <img alt=\"Vue logo\" src=\"../assets/logo.png\">\n   \t<HelloWorld v-for=\"blogPost in blogPosts\" :post=\"blogPost\" :key=\"blogPost.title\" />\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { Component, Vue } from 'vue-property-decorator';\nimport HelloWorld, { Post } from '@/components/HelloWorld.vue'; // @ is an alias to /src\n\n@Component({\n  components: {\n    HelloWorld,\n  },\n})\nexport default class Home extends Vue {\n    private blogPosts: Post[] = [\n        {\n          title: 'My first blogpost ever!',\n          body: 'Lorem ipsum dolor sit amet.',\n          author: 'Elke',\n          datePosted: new Date(2019, 1, 18),\n        },\n        {\n          title: 'Look I am blogging!',\n          body: 'Hurray for me, this is my second post!',\n          author: 'Elke',\n          datePosted: new Date(2019, 1, 19),\n        },\n        {\n          title: 'Another one?!',\n          body: 'Another one!',\n          author: 'Elke',\n          datePosted: new Date(2019, 1, 20),\n        },\n      ];\n}\n</script>这就是简单的父子组件7. 总结而关于Class API撤销，其实还是挺舒服的。 用class 来编写 Vue组件确实太奇怪了。 (所以我这篇Ts入门压根没写Class API)\n            "},{"article_title":"Nuxt.js跳坑指南","description":"等待更新... ...","mate":"1 年前","tags":["NODEJS","相关技术"],"content":"\n                \n等待更新...\n\n\n            "},{"article_title":"Mongo shell指南（CRUD）","description":"MongoDB 概念解析 MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。 MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 Mong ...","mate":"1 年前","tags":["相关技术"],"content":"\n                MongoDB 概念解析\nMongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。\nMongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。\n\n\n\nMongoDB术语/概念\n说明\n\n\n\n\ndatabase\n数据库\n\n\ncollection\n集合\n\n\ndocument\n文档\n\n\nfield\n域\n\n\nindex\n索引\n\n\nprimary key\n主键，MongoDB自动将_id字段设置为主键\n\n\n\n安装MongoDB\n安装MongoDB请参考之前文章MongoDB安装与基本使用\n创建文档\n1. insertOne命令（用于创建单个文档）\ndb.<collection>.insertOne(<document>, { writeConcern: <document> })\n\nwriteConcern定义了本次文档创建的安全写级别（用来判断一次数据库写入操作是否是成功的，安全写级别越高，丢失数据的风险就越低，然而写入操作的延迟也可能更高，不提供writeConcern文档， MongoDB会启用默认的安全写级别）\n\ndb.<collection>.insertOne({\n    _id: \"account1\", //可以自己提供(要保证唯一性)，也可以省略_id主键，mongo自动会为我们生成唯一的文档主键(生成的是ObjectId对象)\n    name: 'jack',\n    balance: 100\n})\n操作成功之后返回\n{ \"acknowledged\" : true, \"insertedId\" : \"account1\" }\nacknowledged：true  //表示默认的安全写级别被启用\ninsertedId：\"account1\"  //表示被插入的主键id为自定义的account1\n\n注意： _id是文档主键，当没有提供文档主键的情况下，默认生成ObjectId用作唯一的文档主键。如果<collection>不存在则会在创建document前先被创建\n\n当储存错误的时候可以进行捕获\ntry {\n    db.<collection>.insertOne({\n        _id: \"account1\",\n        name: 'jack',\n        balance: 100\n    })\n}catch(e) {\n    print(e)\n}\n如果发生错误,会返回WriteError对象，包含了errMsg字段，有详细的错误信息。\n2. insertMany命令 （创建多个文档）\ndb.<collection>.insertMany([<document1>, <document2>, ...], { writeConcern: <document>, ordered: <boolean> })\n\ninsertMany 相比 insertOne多了一个参数ordered, 用来决定mongodb是否要按照顺序来写入这些文档。设置为false 有利于优化写入性能，前面报错，并不影响后一个写入，其默认值为true\n\ndb.<collection>.insertMany([\n    {\n        name: 'test',\n        balance: 1000\n    }, {\n        name: 'spark',\n        balance: 500\n    }\n])\n操作成功之后返回\n{ \"acknowledged\" : true, \"insertedId\" : [\n        ObjectId('1234234323425'),\n        ObjectId('1234567654345')\n    ]\n}\n如果发生错误,会返回BulkWriteError对象，包含了errMsg字段，有出错文档的详细错误信息。\n3. insert命令 创建单个或者多个文档\ndb.<collection>.insert(<document or array of documents>, {writeConcern: <document>, ordered: <boolean>})\n既可以写入一个单一的文档，也可以写入多个文档\ndb.<collection>.insert({\n    name: 'george',\n    balance: 1000\n})\n操作成功之后返回\nWriteResult({\"nInserted\": 1})\n如果发生错误,会返回WriteError对象，包含了writeErrors数组字段，有出错文档的详细错误信息。\ndb.<collection>.insert([\n    {\n        name: '1111',\n        bablace: 800\n    }, {\n        name: '2222',\n        bablace: 200\n    }\n])\n操作成功之后返回\nBulkWriteResult({\n    \"wirteErrors\": [],\n    \"writeConcernErrors\": [],\n    \"nInserted\": 2,\n    ...\n})\n如果发生错误,会返回BulkWriteError对象，包含了writeErrors数组字段，有着出错文档的详细错误信息。\n\n总结：inertOne、insertMany、insert区别\n\n三个命令返回的结果文档格式不一样\ninsertOne和insertMany命令不支持db.<collection>.explain()命令，而insert支持db.<collection>.explain()命令\n\n\n4. save命令\ndb.<collection>.save(<document>, {writeConcern: <document>})\n当save命令处理一个新文档的时候，它会调用db.<collection>.insert()\n\n创建文档操作补充\n主键操作：\n\n可以在shell命令行中，输入ObjectId()来生成主键id\n输入ObjectId(\"数据库中存储的任一主键id\").getTimestamp()，来获取创建时间\n用文档作为文档主键叫做复合主键（复合主键仍要满足文档主键的唯一性）\n\ndb.<collection>.insert({\n    _id: {\n        accountNo: \"001\",\n        type: \"savings\"\n    }, // 复合主键,顺序不一样就不算同一个主键\n    balance: 80\n})\n\n筛选文档\n匹配查询\n\n\n根据字段查询，查询name为alice的文档\ndb.<collection>.find({name: 'alice'})\n\n\n用多个字段查询， 查询name为alice并且balance为100的文档\ndb.<collection>.find({name: 'alice', balance: 100})\n\n\n查询复合文档\ndb.<collection>.find('_id.type': 'savings')\n\n\n比较操作符\n{field: {$<operator>: <value>}}\n\n$eq : 匹配字段值相等的文档\n\n\n$ne: 匹配字段值不相等的文档\n\n\n$gt：匹配字段值大于查询值的文档\n\n\n$gte: 匹配字段值大于或等于查询值的文档\n\n\n$lt: 匹配字段值小于查询值的文档\n\n\n$lte：匹配字段值小于或者等于查询值的文档\n\n{field: {$in: [<value1>, <value2>...<valueN>]}}\n\n$in 匹配字段值与任一查询值相等的文档\n\n\n$nin 匹配字段值与任何值都不相等的文档\n\n\ndb.<collection>.find({name: {$eq: 'alice'}}) //跟匹配查询有相同的效果\n\ndb.<collection>.find({balance: {$ne: 100}}) //查询结果将包含没有此字段的文档\n\ndb.<collection>.find({balance: ${$gt: 500}}) //查询大于balance大于500的文档\n\ndb.<collection>.find({balance: ${$lt:'fred'}}) //查询排在fred之前的文档(abide)\n\ndb.<collection>.find({name: {$in: ['alice', 'charlie']}}) //查询name为alice或者charlie的文档\n\ndb.<collection>.find({name: {$nin: ['alice', 'charlie']}}) //查询name除alice和charlie之外的文档，如果查询的键值不存在，则一并返回没有此键值的文档\n逻辑操作符\n\n$not 匹配筛选条件不成立的文档\n\n{field: {$not: {<operator-expression>}}}\n\n$and 匹配多个筛选条件下全部成立的文档\n\n{$and: [<expression1>, <expression2>....<expressionN>]}\n\n$or  匹配至少一个筛选条件成立的文档\n\n{$or: [<expression1>, <expression2>....<expressionN>]}\n\n$nor 匹配多个筛选条件全部不成立的文档\n\n{$nor: [<expression1>, <expression2>....<expressionN>]}\n如果像下面这样也会查询出不包含查询字段的文档\ndb.<collection>.find({balance: {$not: {$lt: 500}}})\n有些可以简化写\ndb.<collection>.find({$and: [{balance: {$gt: 100}}, {name: {$gt: 'fred'}}]})\n↓↓↓↓↓↓↓ 简化\ndb.<collection>.find({balance: {$gt: 500, $lt: 1000}})\n字段操作符\n\n$exists 匹配包含查询字段的文档\n\n{field: {$exist: <boolean>}}\n\n$type 匹配字段类型符合查询值的文档\n\n{field: {$type: <BSON type>}} or {field: {$type: [<BSON type1>, <BSON type2>, ...]}} \ndb.<collection>.find({'_id.type': {$ne: 'savings', $exists: true}})//查询_id有type字段的文档,并且不等于savings\ndb.<collection>.find({'_id': {$type:['object', 'objectId']}})\ndb.<collection>.find({'_id.type': {$ne: {$type: 'string'}}, exists: true})\ndb.<collection>.find({'name': {$type: 'null'}})\n数组操作符\n\n$all 匹配数组字段中包含所有查询值的文档\n\n{field: {$all: ['value1', 'value2', ....]}}\n\n$elemMatch 匹配数组字段中至少存在一个满足筛选条件的文档\n\n{field: {$elemMatch: {\\<query1>, \\<query2>,...\\<query?>}}}\ndb.<collection>.find({contact: {$all:['CHINA', '10010']}})\ndb.<collection>.find({contact: {$all: [['11111']]}})\ndb.<collection>.find({contact: {$elemMatch: {$eq: '111111'}}})\ndb.<collection>.find({contact: {$elemMatch: {$gt: 100, $lt: 1000}}})\n运算操作符\n\n$regex 匹配满足正则表达式的文档\n\n{field: { $regex: /regex/,<options> }}\n在和$in一起使用的时候需要用这种语法\n{field: {$in:[/regex1/,/regex2/],<options>}}\ndb.<collection>.find({name: {$in:[/^s/, /^j/]}})\ndb.<collection>.find({name: {$regex: /^DW/, $options: 'i'}})\n\n游标 \n\n    筛选操作返回的实际是一个游标，游标指向一个文档集合，不迭代游标的情况下，文档只会列出20个\n    游标遍历完全部文档之后，默认10分钟会自动关闭\n    想要改变其默认行为需要用noCursorTimeout()阻止其自动关闭\n\n    var cursor = db.<collection>.find().noCursorTimeout()  \n    //使用之后需要手动关闭 \n    cursor.close()\n\n游标函数\n    cursor.hasNext() 判断游标中有无剩余的文档\n    cursor.next() 将游标指向下一个文档\n    cursor.forEach(<function>) 遍历游标中指向的文档\n    cursor.limit(<number>) 限制游标返回的文档数量，传入0则不进行限制\n    cursor.skip(<offset>) 跳过游标指向的文档数量\n    cursor.count(<applySkipLimit>) 返回游标文档数量，默认情况下applySkipLimit为false,则不考虑limit和skip之后的数量\n    cursor.sort(<document>) document代表排序的要求 -1逆向排序 1正向排序\n\n\n    cursor.skip()在cursor.limit()之前执行\n    cursor.sort()在cursor.skip()和cursor.limit()之前执行\n\n\n    \n\n文档投影\n\n    db.<collection>.find(<query>, <objection>) \n    利用第二个参数进行文档投影获取想要的字段\n    语法：{field: <inclusion>}\n    1代表返回字段 0表示不返回字段\n\n    db.<collection>.find({name: 'alice'}, {_id: 0, name: 1})\n    其中_id为特殊字段，可为0和1，其余字段有1不能写0， 有0不能写1\n\n    对数组字段中使用投影\n    $slice 只返回数组中的部分数据\n\n    db.<collection>.find({}, {_id:0, name: 1, contact: {$slice: 1}})\n    db.<collection>.find({}, {_id:0, name: 1, contact: {$slice: -1}}) //返回数组字段中倒数一个元素\n    db.<collection>.find({}, {_id:0, name: 1, contact: {$slice: -2}}) //返回数组字段中倒数两个元素\n\n    db.<collection>.find({}, {_id:0, name: 1, contact: {$slice: [1, 3]}}) //$slice数组中第一个元素会进行skip操作，而第二个元素会进行limit操作（跳过第一个元素，返回3个元素）\n    db.<collection>.find({}, {_id: 0, contact: {$elemMatch: {$gt: 'CHINA'}}})\n\n\n更新文档\ndb.<collection>.update(<query>, <update>, <options>)\n\n<query> 定义更新文档的筛选条件，与find中query用法一致\n\n\n<update> 提供文档的更新内容\n\n\n<options> 声明一些更新操作的参数\n\n只会更新查询出所有文档的第一个文档\n更新操作符\n\n$set  更新或者新增字段\n\n{$set: {<field>: <value1>, ...}}\n\n$unset  删除字段\n\n{$unset: {<field>: <value1>, ...}}\n\n$rename  重命名字段\n\n{ $rename: {<field>: <newName1>,<field>: <newName2>}  }\n\n$inc  加减字段值\n\n{$inc: {<field>: <value1>, ...}}\n\n$mul 相乘字段值\n\n{$mul: {<field>: <value1>, ...}}\n\n$min 比较字段值取最小值\n\n{$min: {<field>: <value1>, ...}}\n\n$max 比较字段值取最大值\n\n{$max: {<field>: <value1>, ...}}\n1. $set 用法\ndb.<collection>.update({name: 'jack'}, {\n    $set: {\n        balance: 3000,\n        info: {\n            dateOpened: Date.now(),\n            branch: 'branch1'\n        }\n    }\n})\n\n更新内嵌文档字段db.<collection>.update({name: 'jack'}, {\n    $set: {\n        'info.dateOpened': new Date(2018)\n    }\n})\n\n更新数组内元素db.<collection>.update({\n    name: 'jack'\n}, {\n    $set: {\n        'contact.0': 'spark'\n    }\n})\n\n\n\n如果下标不存在且有跳过的元素，则跳过的元素未赋值的元素都将设置为null\n\n\n添加数组内元素db.<collection>.update({name: 'jack'}, {\n    $set: {\n        'contact.5': 'testIndex'\n    }\n})\n\n\n2. $unset 用法\ndb.<collection>.update({name: 'jack'}, {\n    $unset: {\n        'balance': '', //赋值为空不会对操作结果有任何影响\n        'contact.5': ''\n    }\n})\n\n删除数组内的元素，不会影响数组的长度，而是将其设置为null\n\n3. $rename 用法\n\n如果$rename重命名的字段并不存在，那么对文档内容不会有任何影响。如果新的字段名已经存在，那么原来的字段将被覆盖\n\ndb.<collection>.update({\n    name: 'jack'\n}, {\n    $rename: {\n        bablace: 'name'\n    }\n})\n\n$rename过程是先$unset老的字段， 然后$set新的字段\n\n\n\n操作内嵌文档\n{\n    _id: ObjectId(\"5c9d7cf30c994d956fd6d27d\"),\n    name: 'jack',\n    info: {\n        email: '228436652@qq.com'\n    },\n    balace: 3000\n}\n进行shell操作,使用$rename改变文档中的位置\ndb.<collection>.update({\n    name: 'jack'\n}, {\n    $rename: {\n        'info.balance': 'balace',\n        'email': 'info.email'\n    }\n})\n原来的数据结构将变成\n{\n    _id: ObjectId(\"5c9d7cf30c994d956fd6d27d\"),\n    name: 'jack',\n    info: {\n        balace: 3000\n    },\n    email: '228436652@qq.com'\n}\n\n注意: $rename不可操作位于数组中的元素\n\n\n\n4. $inc与$mul\n\n这两种操作符只能应用在数字字段上，如果$inc操作符用在不存在的字段上，将会把此字段加上并设置value为要加减的值，如果$mul操作符用在不存在的字段上，将会把此字段加上并设置value为0\n\ndb.<collection>.update({\n    name: \"jack\",\n}, {\n    $inc: {\n        balace: -200 //原来的值减去200\n    }\n})\ndb.<collection>.update({\n    name: \"jack\",\n}, {\n    $mul: {\n        balace: 2 //原来的值乘以2\n    }\n})\n5. $min和$max\n\n不只是数字字段可以比较，比如（日期）\n\n{\n    _id: ObjectId(\"5c9d7cf30c994d956fd6d27d\"),\n    num: 10\n}\n以下shell执行后将被设置为10\ndb.<collection>.update({\n    num: 10\n}, {\n    $min: {\n        num: 100\n    }\n})\n以下shell执行后将被设置为100\ndb.<collection>.update({\n    num: 10\n}, {\n    $max: {\n        num: 100\n    }\n})\n\n\n扩展\n\n    如果相比较值的类型不一致， 将会按照BSON数据类型排序规则进行比较\n            null 最小\n            Number\n            Symbol, String\n            Object\n            Array\n            binData\n            ObjectId\n            Boolean\n            Date\n            Timestamp\n            Regular Expresion 最大\n\n\n数组操作符\n\n$addToSet 向数组中添加元素 {}\n\n\n$pop 从数组中移除元素,1代表最后一个 -1代表第一个（只能删除最后一个或者第一个）\n\n\n$pull 从数组中有选择的移除元素\n\n\n$pullAll 从数组中有选择的移除元素\n\n\n$push 向数组中添加元素\n\n1. $addToSet\n{ $addToSet: { <field>: <value1>, <value2>, ... } }\ndb.<collection>.update({name: 'jack'}, {\n    $addToSet: {\n        contact: 'china'\n    }\n})\n\n如果添加的是一个内嵌文档，文档中已有的与添加的完全一致则不会进行覆盖，否则就算是key顺序有变动，依然会进行覆盖\n\n2. $pop\n{ $pop: { <field>: < -1| 1>,...  } }\ndb.<collection>.update({name: 'jack'}, {\n    $pop: {\n        contact: -1\n    }\n})\n\n\n删除内嵌数组\ndb.<collection>.update({name: 'jack'}, {\n    $pop: {\n        \"contact.4\": -1\n    }\n})\n\n\n\n$pop删除数组中所有元素之后 依然会保留空数组\n\n2. $pull\n{$pull: { <field>: <value|condition>}}\ndb.<collection>.update({\n    name: 'jack'\n}, {\n    $pull: {\n        \"contact\": {$regex: /hi/} //不需要用$elemMatch, $pull专门应用于数组字段\n    }\n})\n\n如果说数组元素本身就是一个内嵌数组，那我们就可以用$elemMatch来对这些内嵌数组进行筛选\n\n{\n    _id: ObjectId(\"5c9d7cf30c994d956fd6d27d\"),\n    name: 'jack',\n    info: {\n        balace: 3000\n    },\n    contact: ['china', '17612189352', [111111, 33333333, 2222222]]\n    email: '228436652@qq.com'\n}\n\n利用$elemMatch匹配数组字段中的数组元素中的值\n\ndb.<collection>.update({name: 'jack'}, {\n    $pull: {\n        contact: {\n            $elemMatch: {\n                $eq: 2222222\n            }\n        }\n    }\n})\n{\n    _id: ObjectId(\"5c9d7cf30c994d956fd6d27d\"),\n    name: 'jack',\n    info: {\n        balace: 3000\n    },\n    contact: ['china', '17612189352'] //不会保留空数组\n    email: '228436652@qq.com'\n}\n3. $pullAll\n{$pullAll: { <field>: [<value1>, <value2>, ...]}}\n\n注意$pull比$push命令模糊程度更高，匹配值一定要完全对应，顺序也很重要，但对$pull顺序并不重要\n\n4. $push\n{ $push: { field: <value1>, <value2>, ... } }\ndb.<collection>.update({name: 'jack'}, {\n    $push: {\n        newArray: {\n            $each: [1,2,3,5]   //如果不用$each 将添加成一个内嵌数组，而是以单独元素进行添加\n        }\n    }\n})\n与$push, $each搭配的操作符\n1. $position  插入位置\ndb.<collection>.update({name: 'jack'}, {\n    $push: {\n        newArray: {\n            $each: [1,2,3,5],   //如果不用$each 将添加成一个内嵌数组，而是以单独元素进行添加\n            $position: 0\n        }\n    }\n})\n\n当为负数的时候，意思是将在倒数第几个元素前插入\n\ndb.<collection>.update({name: 'jack'}, {\n    $push: {\n        newArray: {\n            $each: [1,2,3,5],   //如果不用$each 将添加成一个内嵌数组，而是以单独元素进行添加\n            $position: -1 //将插入在倒数第一个元素之前\n        }\n    }\n})\n2. $sort 排序\ndb.<collection>.update({name: 'jack'}, {\n    $push: {\n        newArray: {\n            $each: [1,2,3,5],   //如果不用$each 将添加成一个内嵌数组，而是以单独元素进行添加\n            $sort: 1 //1是数组有小到大排序， -1是从大到小倒序排列\n        }\n    }\n})\n\n\n插入的内嵌文档进行排序\ndb.<collection>.update({name: 'jack'}, {\n    $push: {\n        newArray: {\n            $each: [{\n                key: 'sort1',\n                value: 1\n            }, {\n                key: 'sort2',\n                value: 122\n            }],\n            $sort: {value: -1}\n        }\n    }\n})\n\n\n如果不想插入新的元素， 仅仅想要排序，可以这么写\ndb.<collection>.update({name: 'jack'}, {\n    $push: {\n        newArray: {\n            $each: [],\n            $sort: {value: -1}\n        }\n    }\n})\n\n\n3. $slice 截取部分数组\ndb.<collection>.update({name: 'jack'}, {\n    $push: {\n        newAarray: {\n            $each:[],\n            $slice: -3   //保留数组后三个，正数则一样（3就是保留前三个）\n        }\n    }\n})\n\n他们的执行顺序：$position ==> $sort ==> $slice去执行（书写时候的顺序无所谓的）\n\n占位符\n\n如果mongo中存储一个类似以下这样的文档：\n\n{\n    _id: ObjectId(\"5c9d7cf30c994d956fd6d27d\"),\n    name: 'jack',\n    info: {\n        balace: 3000\n    },\n    contact: ['china', '17612189352', [111111, 33333333, 2222222]]\n    email: '228436652@qq.com'\n}\n1. $ 是数组中第一个符合筛选条件的数组元素的占位符\ndb.<collection>.update(\n    { <array>: <query selector> },\n    { <update operator>: {'<array.$>': value} }\n)\ndb.<collection>.update({\n    name: 'jack',\n    contact: 'china'\n}, {\n    $set: {\n        'contact.$': 'update'\n    }\n})\n↓↓↓\n\n{\n    _id: ObjectId(\"5c9d7cf30c994d956fd6d27d\"),\n    name: 'jack',\n    info: {\n        balace: 3000\n    },\n    contact: ['update', '17612189352', [111111, 33333333, 2222222]]\n    email: '228436652@qq.com'\n}\n2. $[] 更新数组中所有的元素\ndb.<collection>.update({\n    name: 'jack'\n}, {\n    $set: {\n        'contact.2.$[]': 'this is test'\n    }\n})\n↓↓↓ \n\n{\n    _id: ObjectId(\"5c9d7cf30c994d956fd6d27d\"),\n    name: 'jack',\n    info: {\n        balace: 3000\n    },\n    contact: ['update', '17612189352', ['this is test', 'this is test', 'this is test']] //内嵌数组内所有元素都变成了'this is test'.\n    email: '228436652@qq.com'\n}\n\n            "},{"article_title":"快速理解javascript中的Array.prototype.forEach","description":"我们都知道document.querySelectorAll()能够获取dom节点，它返回时的并不是一个真正的数组，而是一个伪数组（NodeList），对于NodeList而言，老古董的IE中它里面是没有forEach方法的,于是经常见到一下这种写法 var doms = d ...","mate":"2 年前","tags":["WEB技术","相关技术"],"content":"\n                \n我们都知道document.querySelectorAll()能够获取dom节点，它返回时的并不是一个真正的数组，而是一个伪数组（NodeList），对于NodeList而言，老古董的IE中它里面是没有forEach方法的,于是经常见到一下这种写法\n\nvar doms = document.querySelectorAll('#dom');\nArray.prototype.forEach.call(doms, function(item) {\n      console.log(item)\n})\n这样将Array原型中方法，赋给要循环的NodeList，通过call改变this指向，传入参数。\n\n至于forEach 方法，它可以接受一个函数参数：\n\n[1,2,3].forEach(function(item) {\n    console.log(item)\n})\n从上面可以看出此时在forEach是数组内置函数，this指向的自然是调用的这个数组（当然并不是说传入的函数内部打印this，那里的this指向的是全局window对象），所以赋予一个数组forEach的时候，需要将this指向这个数组（直接找到原型上的forEach赋予数组）\n如果不理解call函数的用法，请点击这里\n\n            "},{"article_title":"深入babel（实战）","description":"前言：此文章只是个人理解，如有错误希望留言指出 上一篇已经讲了babel的作用和基本配置，那怎么才能应用到自己的项目中呢？这篇文章就以webpack为例，搭建一个简单的webpack应用（前提你你要先安装node环境，这里就不说了，这不是这篇文章的重点，请自行百度） 首先创 ...","mate":"2 年前","tags":["WEB技术","相关技术"],"content":"\n                \n前言：此文章只是个人理解，如有错误希望留言指出\n\n上一篇已经讲了babel的作用和基本配置，那怎么才能应用到自己的项目中呢？这篇文章就以webpack为例，搭建一个简单的webpack应用（前提你你要先安装node环境，这里就不说了，这不是这篇文章的重点，请自行百度）\n\n首先创建一个空的文件夹example-babel，用终端进入此目录中运行\n\n\nnpm init   #这行命令初始化此文件夹，一路回车就ok\n\n\n接着安装babel工具\n\n\nnpm i babel-cli -D\n\n\n安装preset插件\n\n\nnpm i babel-preset-env\n\n\n安装runtime插件，需要的地方将自动转换\n\n\nnpm i babel-plugin-transform-runtime babel-runtime -D\n\n\n编写.babelrc文件，配置插件选项\n\n{\n    \"presets\": [\n        [\n            \"babel-preset-env\",\n            {\n                \"targets\": {\n                    \"browsers\": [\"ie >= 8\", \"chrome >= 62\"]\n                }\n            }\n        ]\n    ],\n    \"plugins\": [\n        \"transform-runtime\"\n    ]\n}\n热更新安装一下，方便编写代码保存的同时能够运行运行代码，我这里用nodemon来运行，\n\nnpm i nodemon -D\n\n不熟悉这个插件的可以先去读一下文档\n在根目录中新建一个src文件夹，运行的js文件都将放在这里\n\n咱们在。package.json添加两行代码,找到scripts添加以下两行代码\n\"scripts\": {\n    \"dev\": \"nodemon -w src -x \\\"babel-node src/test.js\\\"\",\n    \"build\": \"babel src -s -d dist\"\n}\n这时候在test.js写一些es6的语法，就能将es6转成es5了，验证一下运行\n\nnpm run build\n\n看一下dist目录下是不是也有一个test.js跟一个sourcemap文件，打开test.js是不是已经编译成功了？\n\n如果本文有错误之处，欢迎留言指出~\n\n            "},{"article_title":"初探babel","description":"前言：此文章仅仅作为个人理解 babel是一个广泛使用的编译器，可以将es6转成es5代码，从而在现有的环境执行 使用babel的第一步就是配置一下.babelrc文件，存放在项目的根目录下 基本格式如下： { \"presets\": [], &q ...","mate":"2 年前","tags":["WEB技术","相关技术"],"content":"\n                \n前言：此文章仅仅作为个人理解\n\n\nbabel是一个广泛使用的编译器，可以将es6转成es5代码，从而在现有的环境执行\n使用babel的第一步就是配置一下.babelrc文件，存放在项目的根目录下\n\n基本格式如下：\n{\n  \"presets\": [],\n  \"plugins\": []\n}\npresets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。\nES2015转码规则\n$ npm install --save-dev babel-preset-env \n\n官方有一句话这样说：\n\n根据你支持的环境自动决定适合你的 Babel 插件的 Babel preset。它使用了 compat-table\n\n\n在没有任何配置选项的情况下，babel-preset-env 与 babel-preset-latest（或者babel-preset-es2015，babel-preset-es2016和babel-preset-es2017一起）的行为完全相同。\n参考：https://www.babeljs.cn/docs/plugins/preset-env/\n\nES7不同阶段语法提案的转码规则（共有4个阶段），选装一个就行\n$ npm install --save-dev babel-preset-stage-0\n$ npm install --save-dev babel-preset-stage-1\n$ npm install --save-dev babel-preset-stage-2\n$ npm install --save-dev babel-preset-stage-3\n\n\n如果我们没有配置一些规则，Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign ）都不会转码\n\n什么是babel-polyfill\n\n当运行环境中并没有实现的一些方法，babel-polyfill 会给其做兼容。 但是这样做也有一个缺点，就是会污染全局变量，而且项目打包以后体积会增大很多，因为把整个依赖包也搭了进去。所以并不推荐在一些方法类库中去使用。\n\n引入babel-polyfill会有一定副作用，比如：\n\n引入了新的全局对象：比如Promise、WeakMap等。\n修改现有的全局对象：比如修改了Array、String的原型链等\n\n什么是babel-runtime\n为了不污染全局对象和内置的对象原型，但是又想体验使用新鲜语法的快感。就可以配合使用babel-runtime和babel-plugin-transform-runtime。 babel-plugin-transform-runtime用于构建过程的代码转换，babel-runtime是实际导入项目代码的功能模块。 通俗来说，babel-plugin-transform-runtime是babel构建环境的依赖，比如当前运行环境不支持promise，可以通过引入babel-runtime/core-js/promise来获取promise， 或者通过babel-plugin-transform-runtime自动重写你的promise。也许有人会奇怪，为什么会有两个runtime插件，其实是有历史原因的：刚开始开始只有babel-runtime插件，但是用起来很不方便，在代码中直接引入helper 函数，意味着不能共享，造成最终打包出来的文件里有很多重复的helper代码。所以，Babel又开发了babel-plugin-transform-runtime，这个模块会将我们的代码重写，如将Promise重写成_Promise（只是打比方），然后引入_Promise helper函数。这样就避免了重复打包代码和手动引入模块的痛苦。\n使用：\nnpm i babel-plugin-transform-runtime --save-dev\nnpm i babel-runtime --save\n\n\n一定要装这两个才能运行，babel-plugin-transform-runtime依赖于babel-runtime\n\n最后.babelrc配置如下：\n{\n    \"presets\": [\n        [\n            \"babel-preset-env\",\n            {\n                \"targets\": {\n                    \"browsers\": [\"ie >= 8\", \"chrome >= 62\"]\n                }\n            }\n        ]\n    ],\n    \"plugins\": [\n        \"transform-runtime\"\n    ]\n}\n\n            "}]