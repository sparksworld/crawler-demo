[{"article_title":"在git中删除多个远程分支","description":"批量删除本地分支 git branch |grep 'v3.2.8' |xargs git branch -D 批量删远程分支 git branch -r | awk -Forigin/ '/\\/v3.2.8/{print $2}'| xargs -I {} git pus ...","mate":"4 个月前","tags":[],"content":"\n                批量删除本地分支\ngit branch |grep 'v3.2.8' |xargs git branch -D\n\n批量删远程分支\ngit branch -r | awk -Forigin/ '/\\/v3.2.8/{print $2}'| xargs -I {} git push origin :{}\n\n如果上面执行不成功，请检查将删除分支名\nsh     git branch -r | awk -Forigin/ '/\\/v3.2.8/ {print $2}'     \n\n\n\ngrep 命令用于查找文件里符合条件的字符串\nxargs xargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。\nawk命令\n\n\n            "},{"article_title":"用nodejs写服务端接口","description":"待更新 ...","mate":"4 个月前","tags":[],"content":"\n                待更新\n\n\n            "},{"article_title":"npm run dev 换成 pm2","description":"npm run dev 换成 pm2 ...","mate":"1 年前","tags":["黑科技","WEB技术","相关技术"],"content":"\n                \n一开始要用pm2 start一个process，\n\n\nCommands 用 start\nOption 用 --name 进程名\n如何运行package.json原本定义好的scripts中的dev指令？\n\n\n-- run dev\n理解：start npm （这个管理器）的run指令\n\n pm2 start npm --name 名字 -- run dev\n\n\n            "},{"article_title":"使用Mockjs模拟数据请求","description":"用mockjs生成数据,不需要等待接口即可调试 一、安装 用npm包管理工具安装 npm install mockjs 标签引入 <script src=\"http://mockjs.com/dist/mock.js\"></script& ...","mate":"1 年前","tags":["WEB技术","相关技术"],"content":"\n                \n用mockjs生成数据,不需要等待接口即可调试\n\n一、安装\n\n用npm包管理工具安装\n\nnpm install mockjs\n\n\n标签引入\n\n<script src=\"http://mockjs.com/dist/mock.js\"></script>\n二、生成随机数据\nMock.js 的语法规范包括两部分：\n\n数据模板定义（Data Temaplte Definition，DTD）\n数据占位符定义（Data Placeholder Definition，DPD）\n\n1. 将字符串随机重复1遍-10遍\nMock.mock({\n  \"string|1-10\": \"★\"\n})\n\n// {\n//   \"string\": \"★★★\"\n// }\n2. 将一个字符串随机重复5遍\nMock.mock({\n  \"string|5\": \"★\"\n})\n\n// {\n//   \"string\": \"★★★★★\"\n// }\n3. 随机生成一个布尔值，值为 true 的概率是 1/2，值为 false 的概率是 1/2\nMock.mock({\n  \"boolean|1\": true\n})\n\n// {\n//   \"boolean\": true\n// }\n4. 从属性值 {} 中随机选取 2 个属性\nMock.mock({\n  \"object|2\": {\n    \"310000\": \"上海市\",\n    \"320000\": \"江苏省\",\n    \"330000\": \"浙江省\",\n    \"340000\": \"安徽省\"\n  }\n})\n\n// {\n//   \"object\": {\n//     \"310000\": \"上海市\",\n//     \"330000\": \"浙江省\"\n//   }\n// }\n5. 从属性值 {} 中随机选取 2 到 4 个属性\nMock.mock({\n  \"object|2-4\": {\n    \"110000\": \"北京市\",\n    \"120000\": \"天津市\",\n    \"130000\": \"河北省\",\n    \"140000\": \"山西省\"\n  }\n})\n\n// {\n//   \"object\": {\n//     \"110000\": \"北京市\",\n//     \"120000\": \"天津市\",\n//     \"130000\": \"河北省\",\n//     \"140000\": \"山西省\"\n//   }\n// }\n6. 从属性值 [{}, {} ...] 中随机选取 1 个元素，作为最终值\nMock.mock({\n  \"array|1\": [\n    {title:\"AMD\"},\n    {title:\"CMD\"},\n    {title:\"UMD\"},\n  ]\n})\n\n// {\n//   \"array\": {\n//       title:\"CMD\"\n//   }\n// }\n7. 通过重复属性值 [{}, {} ...] 生成一个新数组，重复次数大于等于 2，小于等于 3\nMock.mock({\n  \"array|2-3\": [\n    {title:\"AMD\"},\n    {title:\"CMD\"},\n    {title:\"UMD\"},\n  ]\n})\n\n// {\n//   \"array\": [\n//     {\n//         \"title\": \"AMD\"\n//     },\n//     {\n//         \"title\": \"CMD\"\n//     },\n//     {\n//         \"title\": \"UMD\"\n//     },\n//     {\n//         \"title\": \"AMD\"\n//     },\n//     {\n//         \"title\": \"CMD\"\n//     },\n//     {\n//         \"title\": \"UMD\"\n//     }\n//   ]\n// }\n8. 传入一个正则，返回符合正则的字符串\nMock.mock({\n  'regexp': /[a-z][A-Z][0-9]/\n})\n\n// {\n//   \"regexp\": \"uD2\"\n// }\n9. Mock对象中有一个Random方法，利用Random方法我们可以做很多事情：\nvar Random = Mock.Random\nRandom.integer(20,100)   //随机返回20到100的数字\nRandom.float(60, 100, 3, 5) //随机返回60到100的带有3到5位小数的数字\nRandom.string() //随机返回一个字符串\nRandom.string(5) //随机返回一个长度为5的字符串\nRandom.string(7, 10)//随机返回一个长度为5到7位的字符串\nRandom.date()//随机返回一个日期\nRandom.date('yyyy-MM-dd')//随机返回一个格式化日期\nRandom.image()//随机返回一张图片\nRandom.image('200x100')//随机返回一张带尺寸的图片\nRandom.image('200x100', '#FF6600')//随机返回一张带尺寸和颜色的图片\nRandom.paragraph()//随机返回一段文字\nRandom.cparagraph()//随机返回一段中文文字\nRandom.cparagraph(1, 3)//随机返回1到3段中文文字\nRandom.csentence()//随机返回一句中文\nRandom.ctitle()//随机返回一个中文标题\n三、注意\nMock.mock({\n    'list|2-10': [{\n        'id': Random.integer(20,100),\n        'name':Random.ctitle(),\n        'date':Random.date(\"yyyy-MM-dd\")\n    }]\n});\n\n这样写会使返回的每个数据重复\n\n// {\n//     \"list\": [\n//         {\n//             \"id\": 57,\n//             \"name\": \"边且反认\",\n//             \"date\": \"1989-08-12\"\n//         },\n//         {\n//             \"id\": 57,\n//             \"name\": \"边且反认\",\n//             \"date\": \"1989-08-12\"\n//         },\n//         {\n//             \"id\": 57,\n//             \"name\": \"边且反认\",\n//             \"date\": \"1989-08-12\"\n//         }\n//     ]\n// }\n\n如果想在 list 里返回数据不同的数组, Mock 模板里属性的值可以是 Function\n\nMock.mock({\n    'list|2-10': [{\n        'id': ()=>Random.integer(20,100),\n        'name': ()=>Random.ctitle(),\n        'date':()=>Random.date(\"yyyy-MM-dd\")\n    }]\n});\n\n// {\n//     \"list\": [\n//         {\n//             \"id\": 74,\n//             \"name\": \"但称青气\",\n//             \"date\": \"2004-10-31\"\n//         },\n//         {\n//             \"id\": 32,\n//             \"name\": \"三六属集\",\n//             \"date\": \"2008-06-28\"\n//         },\n//         {\n//             \"id\": 28,\n//             \"name\": \"装造始\",\n//             \"date\": \"1975-04-29\"\n//         }\n//     ]\n// }\n四、参考文章\n\n使用Mock.js模拟数据请求\nMock.js\n\n\n            "},{"article_title":"FormData 对象之文件上传","description":"writeHeader: 表单数据以键值对的形式向服务器发送，这个过程是浏览器自动完成的。但是有时候，我们希望通过脚本完成过程，构造和编辑表单键值对，然后通过XMLHttpRequest.send()方法发送。浏览器原生提供了 FormData 对象来完成这项工作。 用户上传 ...","mate":"1 年前","tags":["WEB技术","相关技术"],"content":"\n                \nwriteHeader: 表单数据以键值对的形式向服务器发送，这个过程是浏览器自动完成的。但是有时候，我们希望通过脚本完成过程，构造和编辑表单键值对，然后通过XMLHttpRequest.send()方法发送。浏览器原生提供了 FormData 对象来完成这项工作。\n\n用户上传文件，也是通过表单。具体来说，就是通过文件输入框选择本地文件，提交表单的时候，浏览器就会把这个文件发送到服务器。\n<input type=\"file\" id=\"file\" name=\"myFile\">\n\n选择文件之后，将文件放入formData\n\nfile.onchange = function (e) {\n    console.log(e.target.files)\n    let formData = new FormData();\n    formData.append('file', e.target.files[0])\n    // 将formData发送给后端post接口，将完成上传\n    // 记得将接口请求haders中的Content-type值改为application/x-www-form-urlencoded\n    console.log(formData.get('file'))\n}\n\n注意：input（type=file）选中相同的文件将不会触发onchange事件可以将input的value重置为空\n\nfile.value = ''\n\n附录\n\nFormData.get(key)：获取指定键名对应的键值，参数为键名。如果有多个同名的键值对，则返回第一个键值对的键值。\nFormData.getAll(key)：返回一个数组，表示指定键名对应的所有键值。如果有多个同名的键值对，数组会包含所有的键值。\nFormData.set(key, value)：设置指定键名的键值，参数为键名。如果键名不存在，会添加这个键值对，否则会更新指定键名的键值。如果第二个参数是文件，还可以使用第三个参数，表示文件名。\nFormData.delete(key)：删除一个键值对，参数为键名。\nFormData.append(key, value)：添加一个键值对。如果键名重复，则会生成两个相同键名的键值对。如果第二个参数是文件，还可以使用第三个参数，表示文件名。\nFormData.has(key)：返回一个布尔值，表示是否具有该键名的键值对。\nFormData.keys()：返回一个遍历器对象，用于for...of循环遍历所有的键名。\nFormData.values()：返回一个遍历器对象，用于for...of循环遍历所有的键值。\nFormData.entries()：返回一个遍历器对象，用于for...of循环遍历所有的键值对。如果直接用for...of循环遍历 FormData 实例，默认就会调用这个方法。\n\n\n            "},{"article_title":"前端图片canvas，file，blob，DataURL等格式转换","description":"将file转化成blob 利用URL.createObjectURL() let $img = document.getElementById('img') file.onchange = function (e) { let file = e.t ...","mate":"1 年前","tags":["WEB技术","相关技术"],"content":"\n                将file转化成blob\n\n利用URL.createObjectURL()\n\nlet $img = document.getElementById('img')\nfile.onchange = function (e) {\n    let file = e.target.files[0]\n    let fileUrl = window.URL.createObjectURL(file)\n    $img.src = fileUrl\n    img.onload = function () {\n        // 手动回收\n        URL.revokeObjectURL(fileUrl)\n    }\n}\n\n当选择图片后，生成的img src类似\"blob:null/4304d4f3-c13b-43e8-83f6-8c80426520ff\"，能正常显示图片。\n\n将file转化为DataURL\n\n利用FileReader.readAsDataURL()\n\nlet $img = document.getElementById('img')\nfile.onchange = function (e) {\n    console.log(e.target.files)\n    let file = e.target.files[0]\n    const fr = new FileReader(file)\n    fr.readAsDataURL(file)\n    fr.onload = function () {\n        $img.src = this.result\n    }\n}\ncanvas转为DataURL\n\ncanvas画出来的图片，在html中的其他地方显示。这里的方法也是可以将canvas输出为Dataurl的来放到img标签中。\n\nlet imgSrc = canvas.toDataURL('image/png')\n// canvas.toDataURL('image/jpeg')\ncanvas转为blob对象\n\n将canvas输出为Blob对象，这样就可以像File对象一样操作它了\n\ncanvas.toBlob(function (blobObj) {\n\tconsole.log(blobObj) //blobObj就是blob对象（类文件）\n})\nBlob对象显示图片\n\n同上,如果拿到blob对象，亦可以使用URL.createObjectURL()来进行转换\n\ncanvas.toBlob(function (blobObj) {\n\tconsole.log(blobObj) //blobObj就是blob对象（类文件）\n    let imgSrc = window.URL.createObjectURL(blobObj)\n\tdocument.getElementById('img').src = imgSrc\n})\n\n最后附一个下载DataURL下载方法：\nfunction downloadImg () {\n\tlet aLink = document.createElement('a')\n\taLink.download = 'fileName.png' // 文件名后缀需要和dataurl表示的相同，否则可能乱码\n\taLink.href = dataUrl\n\taLink.click()\n}\n\n参考前端图片canvas，file，blob，DataURL等格式转换,略作改动。\n\n\n            "}]