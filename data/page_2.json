[{"article_title":"用nodejs写服务端接口","description":"待更新 ...","mate":"4 个月前","tags":{},"content":"\n                待更新\n\n\n            "},{"article_title":"npm run dev 换成 pm2","description":"npm run dev 换成 pm2 ...","mate":"1 年前","tags":{"0":{},"1":{},"2":{}},"content":"\n                \n一开始要用pm2 start一个process，\n\n\nCommands 用 start\nOption 用 --name 进程名\n如何运行package.json原本定义好的scripts中的dev指令？\n\n\n-- run dev\n理解：start npm （这个管理器）的run指令\n\n pm2 start npm --name 名字 -- run dev\n\n\n            "},{"article_title":"使用Mockjs模拟数据请求","description":"用mockjs生成数据,不需要等待接口即可调试 一、安装 用npm包管理工具安装 npm install mockjs 标签引入 <script src=\"http://mockjs.com/dist/mock.js\"></script& ...","mate":"1 年前","tags":{"0":{},"1":{}},"content":"\n                \n用mockjs生成数据,不需要等待接口即可调试\n\n一、安装\n\n用npm包管理工具安装\n\nnpm install mockjs\n\n\n标签引入\n\n<script src=\"http://mockjs.com/dist/mock.js\"></script>\n二、生成随机数据\nMock.js 的语法规范包括两部分：\n\n数据模板定义（Data Temaplte Definition，DTD）\n数据占位符定义（Data Placeholder Definition，DPD）\n\n1. 将字符串随机重复1遍-10遍\nMock.mock({\n  \"string|1-10\": \"★\"\n})\n\n// {\n//   \"string\": \"★★★\"\n// }\n2. 将一个字符串随机重复5遍\nMock.mock({\n  \"string|5\": \"★\"\n})\n\n// {\n//   \"string\": \"★★★★★\"\n// }\n3. 随机生成一个布尔值，值为 true 的概率是 1/2，值为 false 的概率是 1/2\nMock.mock({\n  \"boolean|1\": true\n})\n\n// {\n//   \"boolean\": true\n// }\n4. 从属性值 {} 中随机选取 2 个属性\nMock.mock({\n  \"object|2\": {\n    \"310000\": \"上海市\",\n    \"320000\": \"江苏省\",\n    \"330000\": \"浙江省\",\n    \"340000\": \"安徽省\"\n  }\n})\n\n// {\n//   \"object\": {\n//     \"310000\": \"上海市\",\n//     \"330000\": \"浙江省\"\n//   }\n// }\n5. 从属性值 {} 中随机选取 2 到 4 个属性\nMock.mock({\n  \"object|2-4\": {\n    \"110000\": \"北京市\",\n    \"120000\": \"天津市\",\n    \"130000\": \"河北省\",\n    \"140000\": \"山西省\"\n  }\n})\n\n// {\n//   \"object\": {\n//     \"110000\": \"北京市\",\n//     \"120000\": \"天津市\",\n//     \"130000\": \"河北省\",\n//     \"140000\": \"山西省\"\n//   }\n// }\n6. 从属性值 [{}, {} ...] 中随机选取 1 个元素，作为最终值\nMock.mock({\n  \"array|1\": [\n    {title:\"AMD\"},\n    {title:\"CMD\"},\n    {title:\"UMD\"},\n  ]\n})\n\n// {\n//   \"array\": {\n//       title:\"CMD\"\n//   }\n// }\n7. 通过重复属性值 [{}, {} ...] 生成一个新数组，重复次数大于等于 2，小于等于 3\nMock.mock({\n  \"array|2-3\": [\n    {title:\"AMD\"},\n    {title:\"CMD\"},\n    {title:\"UMD\"},\n  ]\n})\n\n// {\n//   \"array\": [\n//     {\n//         \"title\": \"AMD\"\n//     },\n//     {\n//         \"title\": \"CMD\"\n//     },\n//     {\n//         \"title\": \"UMD\"\n//     },\n//     {\n//         \"title\": \"AMD\"\n//     },\n//     {\n//         \"title\": \"CMD\"\n//     },\n//     {\n//         \"title\": \"UMD\"\n//     }\n//   ]\n// }\n8. 传入一个正则，返回符合正则的字符串\nMock.mock({\n  'regexp': /[a-z][A-Z][0-9]/\n})\n\n// {\n//   \"regexp\": \"uD2\"\n// }\n9. Mock对象中有一个Random方法，利用Random方法我们可以做很多事情：\nvar Random = Mock.Random\nRandom.integer(20,100)   //随机返回20到100的数字\nRandom.float(60, 100, 3, 5) //随机返回60到100的带有3到5位小数的数字\nRandom.string() //随机返回一个字符串\nRandom.string(5) //随机返回一个长度为5的字符串\nRandom.string(7, 10)//随机返回一个长度为5到7位的字符串\nRandom.date()//随机返回一个日期\nRandom.date('yyyy-MM-dd')//随机返回一个格式化日期\nRandom.image()//随机返回一张图片\nRandom.image('200x100')//随机返回一张带尺寸的图片\nRandom.image('200x100', '#FF6600')//随机返回一张带尺寸和颜色的图片\nRandom.paragraph()//随机返回一段文字\nRandom.cparagraph()//随机返回一段中文文字\nRandom.cparagraph(1, 3)//随机返回1到3段中文文字\nRandom.csentence()//随机返回一句中文\nRandom.ctitle()//随机返回一个中文标题\n三、注意\nMock.mock({\n    'list|2-10': [{\n        'id': Random.integer(20,100),\n        'name':Random.ctitle(),\n        'date':Random.date(\"yyyy-MM-dd\")\n    }]\n});\n\n这样写会使返回的每个数据重复\n\n// {\n//     \"list\": [\n//         {\n//             \"id\": 57,\n//             \"name\": \"边且反认\",\n//             \"date\": \"1989-08-12\"\n//         },\n//         {\n//             \"id\": 57,\n//             \"name\": \"边且反认\",\n//             \"date\": \"1989-08-12\"\n//         },\n//         {\n//             \"id\": 57,\n//             \"name\": \"边且反认\",\n//             \"date\": \"1989-08-12\"\n//         }\n//     ]\n// }\n\n如果想在 list 里返回数据不同的数组, Mock 模板里属性的值可以是 Function\n\nMock.mock({\n    'list|2-10': [{\n        'id': ()=>Random.integer(20,100),\n        'name': ()=>Random.ctitle(),\n        'date':()=>Random.date(\"yyyy-MM-dd\")\n    }]\n});\n\n// {\n//     \"list\": [\n//         {\n//             \"id\": 74,\n//             \"name\": \"但称青气\",\n//             \"date\": \"2004-10-31\"\n//         },\n//         {\n//             \"id\": 32,\n//             \"name\": \"三六属集\",\n//             \"date\": \"2008-06-28\"\n//         },\n//         {\n//             \"id\": 28,\n//             \"name\": \"装造始\",\n//             \"date\": \"1975-04-29\"\n//         }\n//     ]\n// }\n四、参考文章\n\n使用Mock.js模拟数据请求\nMock.js\n\n\n            "},{"article_title":"FormData 对象之文件上传","description":"writeHeader: 表单数据以键值对的形式向服务器发送，这个过程是浏览器自动完成的。但是有时候，我们希望通过脚本完成过程，构造和编辑表单键值对，然后通过XMLHttpRequest.send()方法发送。浏览器原生提供了 FormData 对象来完成这项工作。 用户上传 ...","mate":"1 年前","tags":{"0":{},"1":{}},"content":"\n                \nwriteHeader: 表单数据以键值对的形式向服务器发送，这个过程是浏览器自动完成的。但是有时候，我们希望通过脚本完成过程，构造和编辑表单键值对，然后通过XMLHttpRequest.send()方法发送。浏览器原生提供了 FormData 对象来完成这项工作。\n\n用户上传文件，也是通过表单。具体来说，就是通过文件输入框选择本地文件，提交表单的时候，浏览器就会把这个文件发送到服务器。\n<input type=\"file\" id=\"file\" name=\"myFile\">\n\n选择文件之后，将文件放入formData\n\nfile.onchange = function (e) {\n    console.log(e.target.files)\n    let formData = new FormData();\n    formData.append('file', e.target.files[0])\n    // 将formData发送给后端post接口，将完成上传\n    // 记得将接口请求haders中的Content-type值改为application/x-www-form-urlencoded\n    console.log(formData.get('file'))\n}\n\n注意：input（type=file）选中相同的文件将不会触发onchange事件可以将input的value重置为空\n\nfile.value = ''\n\n附录\n\nFormData.get(key)：获取指定键名对应的键值，参数为键名。如果有多个同名的键值对，则返回第一个键值对的键值。\nFormData.getAll(key)：返回一个数组，表示指定键名对应的所有键值。如果有多个同名的键值对，数组会包含所有的键值。\nFormData.set(key, value)：设置指定键名的键值，参数为键名。如果键名不存在，会添加这个键值对，否则会更新指定键名的键值。如果第二个参数是文件，还可以使用第三个参数，表示文件名。\nFormData.delete(key)：删除一个键值对，参数为键名。\nFormData.append(key, value)：添加一个键值对。如果键名重复，则会生成两个相同键名的键值对。如果第二个参数是文件，还可以使用第三个参数，表示文件名。\nFormData.has(key)：返回一个布尔值，表示是否具有该键名的键值对。\nFormData.keys()：返回一个遍历器对象，用于for...of循环遍历所有的键名。\nFormData.values()：返回一个遍历器对象，用于for...of循环遍历所有的键值。\nFormData.entries()：返回一个遍历器对象，用于for...of循环遍历所有的键值对。如果直接用for...of循环遍历 FormData 实例，默认就会调用这个方法。\n\n\n            "},{"article_title":"前端图片canvas，file，blob，DataURL等格式转换","description":"将file转化成blob 利用URL.createObjectURL() let $img = document.getElementById('img') file.onchange = function (e) { let file = e.t ...","mate":"1 年前","tags":{"0":{},"1":{}},"content":"\n                将file转化成blob\n\n利用URL.createObjectURL()\n\nlet $img = document.getElementById('img')\nfile.onchange = function (e) {\n    let file = e.target.files[0]\n    let fileUrl = window.URL.createObjectURL(file)\n    $img.src = fileUrl\n    img.onload = function () {\n        // 手动回收\n        URL.revokeObjectURL(fileUrl)\n    }\n}\n\n当选择图片后，生成的img src类似\"blob:null/4304d4f3-c13b-43e8-83f6-8c80426520ff\"，能正常显示图片。\n\n将file转化为DataURL\n\n利用FileReader.readAsDataURL()\n\nlet $img = document.getElementById('img')\nfile.onchange = function (e) {\n    console.log(e.target.files)\n    let file = e.target.files[0]\n    const fr = new FileReader(file)\n    fr.readAsDataURL(file)\n    fr.onload = function () {\n        $img.src = this.result\n    }\n}\ncanvas转为DataURL\n\ncanvas画出来的图片，在html中的其他地方显示。这里的方法也是可以将canvas输出为Dataurl的来放到img标签中。\n\nlet imgSrc = canvas.toDataURL('image/png')\n// canvas.toDataURL('image/jpeg')\ncanvas转为blob对象\n\n将canvas输出为Blob对象，这样就可以像File对象一样操作它了\n\ncanvas.toBlob(function (blobObj) {\n\tconsole.log(blobObj) //blobObj就是blob对象（类文件）\n})\nBlob对象显示图片\n\n同上,如果拿到blob对象，亦可以使用URL.createObjectURL()来进行转换\n\ncanvas.toBlob(function (blobObj) {\n\tconsole.log(blobObj) //blobObj就是blob对象（类文件）\n    let imgSrc = window.URL.createObjectURL(blobObj)\n\tdocument.getElementById('img').src = imgSrc\n})\n\n最后附一个下载DataURL下载方法：\nfunction downloadImg () {\n\tlet aLink = document.createElement('a')\n\taLink.download = 'fileName.png' // 文件名后缀需要和dataurl表示的相同，否则可能乱码\n\taLink.href = dataUrl\n\taLink.click()\n}\n\n参考前端图片canvas，file，blob，DataURL等格式转换,略作改动。\n\n\n            "},{"article_title":"vue3.0之前TypeScript 最佳入门实践","description":"TypeScript 最佳入门实践 其实Vue官方从2.6.X版本开始就部分使用Ts重写了。 注意此篇标题的“前”，本文旨在讲Ts混入框架的使用，不讲Class API ...","mate":"1 年前","tags":{"0":{},"1":{}},"content":"\n                前言其实Vue官方从2.6.X版本开始就部分使用Ts重写了。注意此篇标题的“前”，本文旨在讲Ts混入框架的使用，不讲Class API1. 使用官方脚手架构建npm install -g @vue/cli\n# OR\nyarn global add @vue/cli新的Vue CLI工具允许开发者 使用 TypeScript 集成环境 创建新项目。只需运行vue create my-app。然后，命令行会要求选择预设。使用箭头键选择Manually select features。接下来，只需确保选择了TypeScript和Babel选项，如下图：完成此操作后，它会询问你是否要使用class-style component syntax。然后配置其余设置，使其看起来如下图所示。Vue CLI工具现在将安装所有依赖项并设置项目。接下来就跑项目喇。总之，先跑起来再说。2. 项目目录解析通过tree指令查看目录结构后可发现其结构和正常构建的大有不同。这里主要关注shims-tsx.d.ts和 shims-vue.d.ts两个文件两句话概括：shims-tsx.d.ts，允许你以.tsx结尾的文件，在Vue项目中编写jsx代码shims-vue.d.ts  主要用于 TypeScript 识别.vue 文件，Ts默认并不支持导入 vue 文件，这个文件告诉ts 导入.vue 文件都按VueConstructor<Vue>处理。此时我们打开亲切的src/components/HelloWorld.vue，将会发现写法已大有不同<template>\n  <div class=\"hello\">\n    <h1>{{ msg }}</h1>\n    <!-- 省略 -->\n  </div>\n</template>\n<script lang=\"ts\">\nimport { Component, Prop, Vue } from 'vue-property-decorator';\n@Component\nexport default class HelloWorld extends Vue {\n@Prop() private msg!: string;\n}\n</script>至此，准备开启新的篇章 TypeScript极速入门 和 vue-property-decorator3. TypeScript极速入门3.1 基本类型和扩展类型Typescript与Javascript共享相同的基本类型，但有一些额外的类型。元组 Tuple枚举 enumAny 与Void1. 基本类型合集// 数字，二、八、十六进制都支持\nlet decLiteral: number = 6;\nlet hexLiteral: number = 0xf00d;\n// 字符串，单双引都行\nlet name: string = \"bob\";\nlet sentence: string = `Hello, my name is ${ name }.\n// 数组，第二种方式是使用数组泛型，Array<元素类型>：\nlet list: number[] = [1, 2, 3];\nlet list: Array<number> = [1, 2, 3];\nlet u: undefined = undefined;\nlet n: null = null;2. 特殊类型1. 元组 Tuple想象 元组 作为有组织的数组，你需要以正确的顺序预定义数据类型。const messyArray = [' something', 2, true, undefined, null];\nconst tuple: [number, string, string] = [24, \"Indrek\" , \"Lasn\"]如果不遵循 为元组 预设排序的索引规则，那么Typescript会警告。​     （tuple第一项应为number类型）2. 枚举 enumenum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。// 默认情况从0开始为元素编号，也可手动为1开始\nenum Color {Red = 1, Green = 2, Blue = 4}\nlet c: Color = Color.Green;另一个很好的例子是使用枚举来存储应用程序状态。3. Void在Typescript中，你必须在函数中定义返回类型。像这样：若没有返回值，则会报错：我们可以将其返回值定义为void:此时将无法 return4. AnyEmmm...就是什么类型都行，当你无法确认在处理什么类型时可以用这个。但要慎重使用，用多了就失去使用Ts的意义。let person: any = \"前端劝退师\"\nperson = 25\nperson = true主要应用场景有：接入第三方库Ts菜逼前期都用5. Never用很粗浅的话来描述就是：\"Never是你永远得不到的爸爸。\"具体的行为是：throw new Error(message)return error(\"Something failed\")while (true) {} // 存在无法达到的终点3. 类型断言简略的定义是：可以用来手动指定一个值的类型。有两种写法，尖括号和as:let someValue: any = \"this is a string\";使用例子有：当 TypeScript 不确定一个联合类型的变量到底是哪个类型的时候，我们只能访问此联合类型的所有类型里共有的属性或方法：function getLength(something: string | number): number {\n    return something.length;\n}如果你访问长度将会报错，而有时候，我们确实需要在还不确定类型的时候就访问其中一个类型的属性或方法，此时需要断言才不会报错：function getLength(something: string | number): number {\n    if ((<string>something).length) {\n        return (<string>something).length;\n    } else {\n        return something.toString().length;\n    }\n}3.2  泛型：Generics软件工程的一个主要部分就是构建组件，构建的组件不仅需要具有明确的定义和统一的接口，同时也需要组件可复用。支持现有的数据类型和将来添加的数据类型的组件为大型软件系统的开发过程提供很好的灵活性。在C#和Java中，可以使用\"泛型\"来创建可复用的组件，并且组件可支持多种数据类型。这样便可以让用户根据自己的数据类型来使用组件。1. 泛型方法在TypeScript里，声明泛型方法有以下两种方式：function gen_func1<T>(arg: T): T {\n    return arg;\n}\n// 或者\nlet gen_func2: <T>(arg: T) => T = function (arg) {\n    return arg;\n}调用方式也有两种：gen_func1<string>('Hello world');\ngen_func2('Hello world');\n// 第二种调用方式可省略类型参数，因为编译器会根据传入参数来自动识别对应的类型。2. 泛型与AnyTs 的特殊类型 Any 在具体使用时，可以代替任意类型，咋一看两者好像没啥区别，其实不然：// 方法一：带有any参数的方法\nfunction any_func(arg: any): any {\n    console.log(arg.length);\n\t\treturn arg;\n}方法一，打印了arg参数的length属性。因为any可以代替任意类型，所以该方法在传入参数不是数组或者带有length属性对象时，会抛出异常。方法二，定义了参数类型是Array的泛型类型，肯定会有length属性，所以不会抛出异常。3. 泛型类型泛型接口：interface Generics_interface<T> {\n    (arg: T): T;\n}\nfunction func_demo<T>(arg: T): T {\nreturn arg;\n}3.3  自定义类型：Interface vs Type aliasInterface，国内翻译成接口。Type alias，类型别名。以下内容来自：Typescript 中的 interface 和 type 到底有什么区别1. 相同点都可以用来描述一个对象或函数：interface User {\n  name: string\n  age: number\n}\ntype User = {\nname: string\nage: number\n};\ninterface SetUser {\n(name: string, age: number): void;\n}\ntype SetUser = (name: string, age: number): void;都允许拓展（extends）：interface 和 type 都可以拓展，并且两者并不是相互独立的，也就是说interface可以 extends type, type 也可以 extends interface 。 虽然效果差不多，但是两者语法不同。interface extends interfaceinterface Name {\n  name: string;\n}\ninterface User extends Name {\n  age: number;\n}type extends typetype Name = {\n  name: string;\n}\ntype User = Name & { age: number  };interface extends typetype Name = {\n  name: string;\n}\ninterface User extends Name {\n  age: number;\n}type extends interfaceinterface Name {\n  name: string;\n}\ntype User = Name & {\n  age: number;\n}2. 不同点type 可以而 interface 不行type 可以声明基本类型别名，联合类型，元组等类型// 基本类型别名\ntype Name = string\n// 联合类型\ninterface Dog {\nwong();\n}\ninterface Cat {\nmiao();\n}\ntype Pet = Dog | Cattype 语句中还可以使用 typeof获取实例的 类型进行赋值// 当你想获取一个变量的类型时，使用 typeof\nlet div = document.createElement('div');\ntype B = typeof div其他骚操作type StringOrNumber = string | number;\ntype Text = string | { text: string };\ntype NameLookup = Dictionary<string, Person>;\ntype Callback<T> = (data: T) => void;\ntype Pair<T> = [T, T];\ntype Coordinates = Pair<number>;\ntype Tree<T> = T | { left: Tree<T>, right: Tree<T> };interface可以而 type不行interface 能够声明合并interface User {\n  name: string\n  age: number\n}\ninterface User {\nsex: string\n}\n/*\nUser 接口为 {\nname: string\nage: number\nsex: string\n}\n*/interface 有可选属性和只读属性可选属性接口里的属性不全都是必需的。 有些是只在某些条件下存在，或者根本不存在。 例如给函数传入的参数对象中只有部分属性赋值了。带有可选属性的接口与普通的接口定义差不多，只是在可选属性名字定义的后面加一个?符号。如下所示interface Person {\n  name: string;\n  age?: number;\n  gender?: number;\n}只读属性顾名思义就是这个属性是不可写的，对象属性只能在对象刚刚创建的时候修改其值。 你可以在属性名前用 readonly来指定只读属性，如下所示：interface User {\n    readonly loginName: string;\n    password: string;\n}上面的例子说明，当完成User对象的初始化后loginName就不可以修改了。3.4 实现与继承：implementsvsextendsextends很明显就是ES6里面的类继承，那么implement又是做什么的呢？它和extends有什么不同？implement，实现。与C#或Java里接口的基本作用一样，TypeScript也能够用它来明确的强制一个类去符合某种契约implement基本用法：interface IDeveloper {\n   name: string;\n   age?: number;\n}\n// OK\nclass dev implements IDeveloper {\n    name = 'Alex';\n    age = 20;\n}\n// OK\nclass dev2 implements IDeveloper {\n    name = 'Alex';\n}\n// Error\nclass dev3 implements IDeveloper {\n    name = 'Alex';\n    age = '9';\n}而extends是继承父类，两者其实可以混着用：class A extends B implements C,D,E搭配 interface和type的用法有：3.5 声明文件与命名空间：declare 和 namespace前面我们讲到Vue项目中的shims-tsx.d.ts和shims-vue.d.ts，其初始内容是这样的：// shims-tsx.d.ts\nimport Vue, { VNode } from 'vue';\ndeclare global {\nnamespace JSX {\n// tslint:disable no-empty-interface\ninterface Element extends VNode {}\n// tslint:disable no-empty-interface\ninterface ElementClass extends Vue {}\ninterface IntrinsicElements {\n[elem: string]: any;\n}\n}\n}\n// shims-vue.d.ts\ndeclare module '*.vue' {\nimport Vue from 'vue';\nexport default Vue;\n}declare：当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。这里列举出几个常用的：declare var 声明全局变量\ndeclare function 声明全局方法\ndeclare class 声明全局类\ndeclare enum 声明全局枚举类型\ndeclare global 扩展全局变量\ndeclare module 扩展模块namespace：“内部模块”现在称做“命名空间”module X { 相当于现在推荐的写法 namespace X {)跟其他 JS 库协同类似模块，同样也可以通过为其他 JS 库使用了命名空间的库创建 .d.ts 文件的声明文件，如为 D3 JS 库，可以创建这样的声明文件：declare namespace D3{\n    export interface Selectors { ... }\n}\ndeclare var d3: D3.Base;所以上述两个文件：shims-tsx.d.ts， 在全局变量 global中批量命名了数个内部模块。shims-vue.d.ts，意思是告诉 TypeScript *.vue 后缀的文件可以交给 vue 模块来处理。3.6 访问修饰符：private、public、protected其实很好理解：默认为public当成员被标记为private时，它就不能在声明它的类的外部访问，比如：class Animal {\n    private name: string;\n    constructor(theName: string) {\n        this.name = theName;\n    }\n}protected和private类似，但是，protected成员在派生类中可以访问class Animal {\n    protected name: string;\n    constructor(theName: string) {\n        this.name = theName;\n    }\n}3.7 可选参数 ( ?: )和非空断言操作符（!.）可选参数function buildName(firstName: string, lastName?: string) {\n    return firstName + ' ' + lastName\n}非空断言操作符：能确定变量值一定不为空时使用。与可选参数 不同的是，非空断言操作符不会防止出现 null 或 undefined。let s = e!.name;  // 断言e是非空并访问name属性4. Vue组件的Ts写法从 vue2.5 之后，vue 对 ts 有更好的支持。根据官方文档，vue 结合 typescript ，有两种书写方式：**Vue.extend **import Vue from 'vue'vue-class-componentimport { Component, Vue, Prop } from 'vue-property-decorator'\n\n@Component\nexport default class Test extends Vue {\n  @Prop({ type: Object })\n  private test: { value: string }\n}理想情况下，Vue.extend 的书写方式，是学习成本最低的。在现有写法的基础上，几乎 0 成本的迁移。但是Vue.extend模式，需要与mixins 结合使用。在 mixin 中定义的方法，不会被 typescript 识别到，这就意味着会出现丢失代码提示、类型检查、编译报错等问题。菜鸟才做选择，大佬都挑最好的。直接讲第二种吧：4.1 vue-class-component我们回到src/components/HelloWorld.vue<template>\n  <div class=\"hello\">\n    <h1>{{ msg }}</h1>\n    <!-- 省略 -->\n  </div>\n</template>\n<script lang=\"ts\">\nimport { Component, Prop, Vue } from 'vue-property-decorator';\n@Component\nexport default class HelloWorld extends Vue {\n@Prop() private msg!: string;\n}\n</script>有写过python的同学应该会发现似曾相识：vue-property-decorator这个官方支持的库里，提供了函数 **装饰器（修饰符）**语法1.  函数修饰符 @“@”，与其说是修饰函数倒不如说是引用、调用它修饰的函数。或者用句大白话描述：@: \"下面的被我包围了。\"举个栗子，下面的一段代码，里面两个函数，没有被调用，也会有输出结果：test(f){\n    console.log(\"before ...\");\n    f()\n\t\tconsole.log(\"after ...\");\n }直接运行，输出结果：before ...\nfunc was called\nafter ...上面代码可以看出来:只定义了两个函数：test和func，没有调用它们。如果没有“@test”，运行应该是没有任何输出的。但是，解释器读到函数修饰符“@”的时候，后面步骤会是这样：去调用test函数，test函数的入口参数就是那个叫“func”的函数；test函数被执行，入口参数的（也就是func函数）会被调用（执行）；换言之，修饰符带的那个函数的入口参数，就是下面的那个整个的函数。有点儿类似JavaScript里面的 function a (function () { ... });2. vue-property-decorator和vuex-class提供的装饰器vue-property-decorator的装饰器：@Prop@PropSync@Provide@Model@Watch@Inject@Provide@Emit@Component (provided by vue-class-component)Mixins (the helper function named mixins provided by vue-class-component)vuex-class的装饰器：@State@Getter@Action@Mutation我们拿原始Vue组件模版来看：import {componentA,componentB} from '@/components';以上模版替换成修饰符写法则是：import { Component, Vue, Prop } from 'vue-property-decorator';\nimport { State, Getter } from 'vuex-class';\nimport { count, name } from '@/person'\nimport { componentA, componentB } from '@/components';\n\n@Component({\n    components:{ componentA, componentB},\n})\nexport default class HelloWorld extends Vue{\n\t@Prop(Number) readonly propA!: number | undefined\n    @Prop({ default: 'default value' }) readonly propB!: string\n    @Prop([String, Boolean]) readonly propC!: string | boolean | undefined\n\n  // 原data\n  message = 'Hello'\n\n  // 计算属性\n\tprivate get reversedMessage (): string[] {\n  \treturn this.message.split('').reverse().join('')\n  }\n  // Vuex 数据\n  @State((state: IRootState) => state . booking. currentStep) step!: number\n\t@Getter( 'person/name') name!: name\n\n  // method\n  public changeMessage (): void {\n    this.message = 'Good bye'\n  },\n  public getName(): string {\n    let storeName = name\n    return storeName\n  }\n\t// 生命周期\n  private created ()：void { },\n  private mounted ()：void { },\n  private updated ()：void { },\n  private destroyed ()：void { }\n}正如你所看到的，我们在生命周期 列表那都添加private XXXX方法，因为这不应该公开给其他组件。而不对method做私有约束的原因是，可能会用到@Emit来向父组件传递信息。4.2 添加全局工具引入全局模块，需要改main.ts:import Vue from 'vue';\nimport App from './App.vue';\nimport router from './router';\nimport store from './store';\nVue.config.productionTip = false;npm i VueI18nimport Vue from 'vue';\nimport App from './App.vue';\nimport router from './router';\nimport store from './store';\n// 新模块\nimport i18n from './i18n';\n\nVue.config.productionTip = false;\n\nnew Vue({\n    router,\n    store,\n    i18n, // 新模块\n    render: (h) => h(App),\n}).$mount('#app');但仅仅这样，还不够。你需要动src/vue-shim.d.ts：// 声明全局方法\ndeclare module 'vue/types/vue' {\n  interface Vue {\n        readonly $i18n: VueI18Next;\n        $t: TranslationFunction;\n    }\n}之后使用this.$i18n()的话就不会报错了。4.3 Axios 使用与封装Axios的封装千人千面如果只是想简单在Ts里体验使用Axios，可以安装vue-axios简单使用Axios$ npm i axios vue-axios\n复制代码main.ts添加：import Vue from 'vue'\nimport axios from 'axios'\nimport VueAxios from 'vue-axios'然后在组件内使用：Vue.axios.get(api).then((response) => {\n  console.log(response.data)\n})\n\nthis.axios.get(api).then((response) => {\n  console.log(response.data)\n})\n\nthis.$http.get(api).then((response) => {\n  console.log(response.data)\n})1. 新建文件request.ts文件目录:-api\n    - main.ts   // 实际调用\n-utils\n    - request.ts  // 接口封装2. request.ts文件解析import * as axios from 'axios';\nimport store from '@/store';\n// 这里可根据具体使用的UI组件库进行替换\nimport { Toast } from 'vant';\nimport { AxiosResponse, AxiosRequestConfig } from 'axios';\n/* baseURL 按实际项目来定义 */\nconst baseURL = process.env.VUE_APP_URL;\n/* 创建axios实例 */\nconst service = axios.default.create({\nbaseURL,\ntimeout: 0, // 请求超时时间\nmaxContentLength: 4000,\n});\nservice.interceptors.request.use((config: AxiosRequestConfig) => {\nreturn config;\n}, (error: any) => {\nPromise.reject(error);\n});\nservice.interceptors.response.use(\n(response: AxiosResponse) => {\nif (response.status !== 200) {\nToast.fail('请求错误！');\n} else {\nreturn response.data;\n}\n},\n(error: any) => {\nreturn Promise.reject(error);\n});为了方便，我们还需要定义一套固定的 axios 返回的格式，新建ajax.ts：export interface AjaxResponse {\n    code: number;\n    data: any;\n    message: string;\n}3. main.ts接口调用：// api/main.ts\nimport request from '../utils/request';\n\n// get\nexport function getSomeThings(params:any) {\n    return request({\n        url: '/api/getSomethings',\n    });\n}\n\n// post\nexport function postSomeThings(params:any) {\n    return request({\n        url: '/api/postSomethings',\n        methods: 'post',\n        data: params\n    });\n}5. 编写一个组件为了减少时间，我们来替换掉src/components/HelloWorld.vue，做一个博客帖子组件：<template>\n\t<div class=\"blogpost\">\n\t\t<h2>{{ post.title }}</h2>\n\t\t<p>{{ post.body }}</p>\n\t\t<p class=\"meta\">Written by {{ post.author }} on {{ date }}</p>\n\t</div>\n</template>\n<script lang=\"ts\">\nimport { Component, Prop, Vue } from 'vue-property-decorator';\n// 在这里对数据进行类型约束\nexport interface Post {\ntitle: string;\nbody: string;\nauthor: string;\ndatePosted: Date;\n}\n@Component\nexport default class HelloWorld extends Vue {\n@Prop() private post!: Post;\nget <span class=\"hljs-function\"><span class=\"hljs-title\">date</span></span>() {\n\t<span class=\"hljs-built_in\">return</span> `<span class=\"hljs-variable\">${this.post.datePosted.getDate()}</span>/<span class=\"hljs-variable\">${this.post.datePosted.getMonth()}</span>/<span class=\"hljs-variable\">${this.post.datePosted.getFullYear()}</span>`;\n}\n\n}\n</script>然后在Home.vue中使用:<template>\n  <div class=\"home\">\n    <img alt=\"Vue logo\" src=\"../assets/logo.png\">\n   \t<HelloWorld v-for=\"blogPost in blogPosts\" :post=\"blogPost\" :key=\"blogPost.title\" />\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { Component, Vue } from 'vue-property-decorator';\nimport HelloWorld, { Post } from '@/components/HelloWorld.vue'; // @ is an alias to /src\n\n@Component({\n  components: {\n    HelloWorld,\n  },\n})\nexport default class Home extends Vue {\n    private blogPosts: Post[] = [\n        {\n          title: 'My first blogpost ever!',\n          body: 'Lorem ipsum dolor sit amet.',\n          author: 'Elke',\n          datePosted: new Date(2019, 1, 18),\n        },\n        {\n          title: 'Look I am blogging!',\n          body: 'Hurray for me, this is my second post!',\n          author: 'Elke',\n          datePosted: new Date(2019, 1, 19),\n        },\n        {\n          title: 'Another one?!',\n          body: 'Another one!',\n          author: 'Elke',\n          datePosted: new Date(2019, 1, 20),\n        },\n      ];\n}\n</script>这就是简单的父子组件7. 总结而关于Class API撤销，其实还是挺舒服的。 用class 来编写 Vue组件确实太奇怪了。 (所以我这篇Ts入门压根没写Class API)\n            "}]